<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atlas - Interactive Geography Learning Platform | World Geography Games & Education</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Learn world geography through interactive games, daily puzzles, and educational challenges. Atlas offers population games, time-based challenges, football mode, and more. Perfect for students, teachers, and geography enthusiasts.">
    <meta name="keywords" content="geography learning, world geography, interactive geography games, educational games, geography education, world map games, country identification, population geography, time zones, football geography, geography puzzles, Atlas platform, geography learning tools, educational technology">
    <meta name="author" content="Atlas Team">
    <meta name="robots" content="index, follow">
    <meta name="language" content="English">
    <meta name="revisit-after" content="7 days">
    
    <!-- Favicons -->
    <link rel="icon" type="image/png" sizes="48x48" href="icon48x48.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icon512x512.png">
    <link rel="apple-touch-icon" href="icon512x512.png">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Atlas - Interactive Geography Learning Platform">
    <meta property="og:description" content="Learn world geography through interactive games, daily puzzles, and educational challenges. Atlas offers population games, time-based challenges, football mode, and more.">
    <meta property="og:image" content="preview.png">
    <meta property="og:url" content="https://atlas.killmytime.fun/">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Atlas">
    <meta property="og:locale" content="en_US">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Atlas - Interactive Geography Learning Platform">
    <meta name="twitter:description" content="Learn world geography through interactive games, daily puzzles, and educational challenges. Atlas offers population games, time-based challenges, football mode, and more.">
    <meta name="twitter:image" content="preview.png">
    
    <!-- Canonical tag -->
    <link rel="canonical" href="https://atlas.killmytime.fun/">
    
    <!-- Schema.org Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebSite",
        "name": "Atlas - Interactive Geography Learning Platform",
        "description": "Learn world geography through interactive games, daily puzzles, and educational challenges. Atlas offers population games, time-based challenges, football mode, and more.",
        "url": "https://atlas.killmytime.fun/",
        "potentialAction": {
            "@type": "SearchAction",
            "target": "https://atlas.killmytime.fun/search?q={search_term_string}",
            "query-input": "required name=search_term_string"
        },
        "publisher": {
            "@type": "Organization",
            "name": "Atlas",
            "url": "https://atlas.killmytime.fun"
        }
    }
    </script>
    
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Organization",
        "name": "Atlas",
        "url": "https://atlas.killmytime.fun",
        "logo": "https://atlas.killmytime.fun/icon512x512.png",
        "description": "Interactive geography learning platform offering educational games and tools",
        "sameAs": [
            "https://atlas.killmytime.fun/blog.html"
        ]
    }
    </script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Kirang+Haerang&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Vercel Analytics -->
    <script>
        window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
      </script>
      <script defer src="/_vercel/insights/script.js"></script>

    <!-- Yandex Metrika -->
    <script type="text/javascript">
        (function(m,e,t,r,i,k,a){
            m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
            m[i].l=1*new Date();
            for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
            k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)
        })(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=103847760', 'ym');

        ym(103847760, 'init', {ssr:true, webvisor:true, clickmap:true, ecommerce:"dataLayer", accurateTrackBounce:true, trackLinks:true});
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/103847760" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

    <!-- Umami Analytics -->
    <script defer src="https://cloud.umami.is/script.js" data-website-id="8d28733e-73b9-493a-95ea-8afde5b14cb0"></script>
   
   <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1M6H8PMLDP"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-1M6H8PMLDP');
    </script>
    
   <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --bg-accent: #e2e8f0;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --accent-color: #333333;
            --border-color: #cbd5e1;
            --shadow-color: rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Mouse Trail Canvas */
        #fluid-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            background: transparent;
            cursor: crosshair;
            pointer-events: none;
            mix-blend-mode: multiply;
        }
        


        /* Squared grid lines background */
        .bg-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            background-image: 
                linear-gradient(rgba(100, 100, 100, 0.15) 1px, transparent 1px),
                linear-gradient(90deg, rgba(100, 100, 100, 0.15) 1px, transparent 1px);
            background-size: 20px 20px;
        }





        /* Header */
        .header {
            text-align: center;
            padding: 4rem 2rem 2rem;
        }

        .title {
            font-size: 3.5rem;
            font-weight: 700;
            font-family: 'Kirang Haerang', cursive;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #1e293b, #333333);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            position: relative;
            display: inline-block;
        }

        .title span {
            display: inline-block;
            opacity: 0;
            transform: translateY(20px);
            animation: drawLetter 0.6s ease forwards;
            background: linear-gradient(135deg, #1e293b, #333333);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .title span:nth-child(1) { animation-delay: 0.1s; }
        .title span:nth-child(2) { animation-delay: 0.2s; }
        .title span:nth-child(3) { animation-delay: 0.3s; }
        .title span:nth-child(4) { animation-delay: 0.4s; }
        .title span:nth-child(5) { animation-delay: 0.5s; }

        @keyframes drawLetter {
            0% {
                opacity: 0;
                transform: translateY(20px) scale(0.8);
            }
        }
        
        /* Country emoji marker styling */
        .country-emoji-marker {
            background: transparent;
            border: none;
        }
        
        .emoji-marker {
            font-size: 24px;
            text-align: center;
            line-height: 30px;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.7));
            transition: transform 0.2s ease;
        }
        
        .emoji-marker:hover {
            transform: scale(1.2);
        }
        
        .country-tooltip {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #22c55e;
            border-radius: 8px;
            color: white;
            font-family: 'Inter', sans-serif;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        .country-tooltip-content {
            padding: 12px;
            text-align: center;
            min-width: 200px;
        }
        
        .country-emoji {
            font-size: 32px;
            margin-bottom: 8px;
        }
        
        .country-name {
            font-size: 16px;
            font-weight: bold;
            color: #1f1f1f;
            margin-bottom: 6px;
        }
        
        .country-description {
            font-size: 14px;
            color: #1d1d1d;
            line-height: 1.4;
        }
        
        /* Map title styling */
        .map-title {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #ffffff;
            font-family: 'Inter', sans-serif;
            font-size: 18px;
            font-weight: 500;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border: 1px solid #ffffff;
            border-radius: 0;
            letter-spacing: 0.5px;
        }
        
        /* Country info modal styling */
        .country-info-modal {
            font-family: 'Inter', sans-serif;
        }
        
        .country-info-content {
            background: #000000;
            border: 1px solid #ffffff;
            border-radius: 0;
            padding: 24px;
            max-width: 700px;
            width: 90%;
            max-height: 70vh;
            overflow-y: auto;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.1);
            position: relative;
        }
        
        .country-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid #ffffff;
        }
        
        .country-info-header h2 {
            color: #ffffff;
            margin: 0;
            font-size: 28px;
            font-weight: 400;
            font-family: 'Inter', sans-serif;
            letter-spacing: -0.5px;
        }
        
        .close-btn {
            background: none;
            border: 1px solid #ffffff;
            color: #ffffff;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
        }
        
        .close-btn:hover {
            background: #ffffff;
            color: #000000;
        }
        
        .country-info-body {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }
        
        .country-display {
            text-align: center;
            padding: 20px;
            background: #111111;
            border: 1px solid #ffffff;
            border-radius: 0;
        }
        
        .country-emoji-large {
            font-size: 48px;
            margin-bottom: 16px;
            display: block;
        }
        
        .country-description-large {
            color: #ffffff;
            font-size: 16px;
            line-height: 1.6;
            margin: 0;
            font-family: 'Inter', sans-serif;
            font-weight: 300;
            max-width: 500px;
            margin: 0 auto;
        }
        
        .editors-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
        }
        
        .emoji-editor {
            background: #111111;
            border: 1px solid #ffffff;
            border-radius: 0;
            padding: 20px;
        }
        
        .emoji-editor h3 {
            color: #ffffff;
            margin: 0 0 20px 0;
            font-size: 18px;
            text-align: center;
            font-family: 'Inter', sans-serif;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .emoji-suggestions {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 6px;
            margin-bottom: 16px;
        }
        
        .emoji-suggestion {
            background: #000000;
            border: 1px solid #ffffff;
            border-radius: 0;
            padding: 10px 6px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 38px;
        }
        
        .emoji-suggestion:hover {
            background: #ffffff;
            color: #000000;
            transform: scale(1.05);
        }
        
        .custom-emoji-input {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .emoji-input {
            background: #000000;
            border: 1px solid #ffffff;
            border-radius: 0;
            padding: 12px;
            color: #ffffff;
            font-size: 16px;
            font-family: 'Inter', sans-serif;
            text-align: center;
        }
        
        .emoji-input:focus {
            outline: none;
            border-color: #ffffff;
            background: #111111;
        }
        
        .emoji-input::placeholder {
            color: #666666;
        }
        
        .set-emoji-btn {
            background: #ffffff;
            color: #000000;
            border: 1px solid #ffffff;
            border-radius: 0;
            padding: 12px 16px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .set-emoji-btn:hover {
            background: #000000;
            color: #ffffff;
        }
        
        /* Description editor styling */
        .description-editor {
            background: #111111;
            border: 1px solid #ffffff;
            border-radius: 0;
            padding: 20px;
        }
        
        .description-editor h3 {
            font-size: 18px;
            color: #ffffff;
            margin-bottom: 20px;
            text-align: center;
            font-family: 'Inter', sans-serif;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .description-input-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .description-input {
            background: #000000;
            border: 1px solid #ffffff;
            border-radius: 0;
            padding: 12px;
            color: #ffffff;
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            resize: vertical;
            min-height: 80px;
            line-height: 1.5;
        }
        
        .description-input:focus {
            outline: none;
            border-color: #ffffff;
            background: #111111;
        }
        
        .description-input::placeholder {
            color: #666666;
        }
        
        .set-description-btn {
            background: #ffffff;
            color: #000000;
            border: 1px solid #ffffff;
            border-radius: 0;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            align-self: flex-end;
            font-family: 'Inter', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .set-description-btn:hover {
            background: #000000;
            color: #ffffff;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .country-info-content {
                padding: 24px;
                margin: 20px;
            }
            
            .editors-container {
                grid-template-columns: 1fr;
                gap: 24px;
            }
            
            .emoji-suggestions {
                grid-template-columns: repeat(6, 1fr);
            }
            
            .country-info-header h2 {
                font-size: 24px;
            }
        }
        
        /* Toast notification animation */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        /* Country image overlay styling */
        .country-image-overlay {
            border: 2px solid #22c55e !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3) !important;
            object-fit: cover !important;
            object-position: center !important;
        }
        
        .country-image-overlay:hover {
            border-color: #16a34a !important;
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.5) !important;
        }
        
        /* Ensure images fit properly within country boundaries */
        .country-image-overlay img {
            width: 100% !important;
            height: 100% !important;
            object-fit: cover !important;
            object-position: center !important;
        }
        
        /* NEW: Clipped image overlay styling for perfect border fit */
        .country-image-overlay-clipped {
            border: 3px solid #22c55e !important;
            border-radius: 0 !important;
            box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.3) !important;
            clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%) !important;
        }
        
        .country-image-overlay-clipped:hover {
            border-color: #16a34a !important;
            box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.5) !important;
        }
        
        /* NEW: Exact shape image overlay styling - looks like hover effect */
        .country-image-overlay-exact-shape {
            border: 2px solid #16a34a !important;
            border-radius: 0 !important;
            box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.2) !important;
            /* This will make it look like the hover effect */
            background: rgba(34, 197, 94, 0.1) !important;
        }
        
        .country-image-overlay-exact-shape:hover {
            border-color: #15803d !important;
            box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.4) !important;
            background: rgba(34, 197, 94, 0.2) !important;
        }
        
        /* NEW: Perfect shape image overlay styling with SVG clipping */
        .country-image-overlay-perfect-shape {
            border: none !important;
            border-radius: 0 !important;
            box-shadow: none !important;
            background: none !important;
            /* This will be clipped to the exact country shape */
            mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg"><defs><mask id="country-mask"><rect width="100%" height="100%" fill="white"/></mask></defs></svg>') !important;
            -webkit-mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg"><defs><mask id="country-mask"><rect width="100%" height="100%" fill="white"/></mask></defs></svg>') !important;
        }
        
        .country-image-overlay-perfect-shape:hover {
            /* No hover effects needed - image is perfectly clipped */
        }
        
        @keyframes drawLetter {
            0% {
                opacity: 0;
                transform: translateY(20px) scale(0.8);
            }
            50% {
                opacity: 0.7;
                transform: translateY(-5px) scale(1.1);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .title::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 0;
            height: 3px;
            background: linear-gradient(135deg, #1e293b, #333333);

            animation-delay: 0.8s;
        }


        

        /* Constant minimal animation for Atlas text */
        .title {
            animation: breathe 3s ease-in-out infinite;
        }

        @keyframes breathe {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.02);
            }
        }

        .title span {
            animation: drawLetter 0.6s ease forwards, float 4s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-3px);
            }
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--text-secondary);
            font-weight: 400;
            margin-bottom: 2rem;
        }
        
        .game-map-container {
            margin: 1.5rem 0;
            text-align: center;
            position: relative;
        }
        
        .map-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            pointer-events: none;
        }
        
        .timer-overlay {
            position: absolute;
            top: 10px;
            left: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: var(--text-primary);
            font-weight: 600;
        }
        
        .instructions-overlay {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        .puzzle-selector-connected {
            display: flex;
            justify-content: center;
            gap: 0.3rem;
            margin: 0 auto;
            padding: 0.3rem;
            background: var(--bg-accent);
            border: 3px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-width: 400px;
            box-shadow: 0 2px 8px var(--shadow-color);
        }
        

        
        .puzzle-square {
            width: 45px;
            height: 45px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .puzzle-square:hover {
            transform: translateY(-2px);
            border-color: var(--accent-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .puzzle-square.current {
            border-color: var(--accent-color);
            background: var(--accent-color);
            color: rgb(255, 0, 0);
        }
        
        .puzzle-square.completed {
            border-color: #10b981;
            background: #10b981;
            color: white;
            cursor: pointer;
            opacity: 1;
        }
        
        .puzzle-square.submitted {
            border-color: #059669;
            background: #059669;
            color: white;
            cursor: pointer;
            opacity: 1;
            position: relative;
        }
        
        .puzzle-square.submitted::after {
            content: 'üèÜ';
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 12px;
            background: #fbbf24;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
        }
        
        .puzzle-square.locked {
            border-color: #6b7280;
            background: #f3f4f6;
            cursor: pointer;
            opacity: 0.7;
        }
        
        .puzzle-square.available {
            border-color: #10b981;
            background: #10b981;
            color: white;
            cursor: pointer;
            opacity: 1;
        }
        
        /* Custom tooltip for puzzle squares */
        .puzzle-square[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.3s ease;
        }
        
        .puzzle-square[title]:hover::before {
            content: '';
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            pointer-events: none;
        }
        

        
        .puzzle-number {
            font-size: 1rem;
            font-weight: 700;
            line-height: 1;
        }
        
        .puzzle-square.current .puzzle-number,
        .puzzle-square.completed .puzzle-number {
            color: white;
        }
        
        .atlas-minimap {
            width: 100%;
            max-width: 600px;
            height: 300px;
            background: var(--bg-accent);
            border: 5px solid var(--border-color);
            border-radius: 8px;
            margin: 0 auto;
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 12px var(--shadow-color);
        }
        
        .map-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 9999;
            pointer-events: none;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .timer-overlay {
            position: absolute;
            top: 10px;
            left: 15px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            color: #000;
            font-weight: 700;
            padding: 8px 12px;
            border-radius: 6px;
            z-index: 10000;
        }
        
        .instructions-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
            color: #000;
            font-weight: 700;
            padding: 12px 16px;
            border-radius: 8px;
            z-index: 10000;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .instructions-overlay.game-started {
            top: 10px;
            left: auto;
            right: 15px;
            transform: none;
            font-size: 14px;
            padding: 8px 12px;
            border-radius: 6px;
        }
        
        #tsparticles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9998;
            pointer-events: none;
        }
        
        .results-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10002;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 1rem;
            box-sizing: border-box;
            pointer-events: none;
        }
        
        .leaderboard-section {
            margin-top: 4rem;
            padding: 2rem;
            background: var(--bg-secondary);
            border-radius: 16px;
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .leaderboard-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        
        .leaderboard-header h2 {
            font-size: 2.5rem;
            color: var(--accent-color);
            margin-bottom: 0.5rem;
        }
        
        .leaderboard-header p {
            font-size: 1.1rem;
            color: var(--text-secondary);
        }
        
        .view-leaderboard-btn {
            margin-top: 1rem;
            padding: 0.75rem 1.5rem;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .view-leaderboard-btn:hover {
            background: #555;
            transform: translateY(-1px);
        }
        
        .score-submission {
            margin-bottom: 2rem;
        }
        
        .submission-container {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            max-width: 500px;
            margin: 0 auto;
        }
        
        .submission-container h3 {
            font-size: 1.5rem;
            color: var(--accent-color);
            margin-bottom: 1.5rem;
        }
        
        .submission-form {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            align-items: center;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
        }
        
        .form-group label {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 1rem;
        }
        
        .name-input {
            padding: 0.75rem 1rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 1rem;
            min-width: 200px;
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        
        .name-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(51, 51, 51, 0.1);
        }
        
        .submit-score-btn {
            padding: 0.75rem 1.5rem;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .submit-score-btn:hover {
            background: #555;
            transform: translateY(-1px);
        }
        
        .submit-score-btn:disabled {
            background: #999;
            cursor: not-allowed;
            transform: none;
        }
        
        .flag-selector {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(35px, 1fr));
            gap: 4px;
            max-width: 350px;
            max-height: 200px;
            overflow-y: auto;
            padding: 0.75rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
        }
        
        .flag-option {
            width: 35px;
            height: 35px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 6px;
            transition: all 0.2s ease;
            background: var(--bg-primary);
        }
        
        .flag-option:hover {
            border-color: var(--accent-color);
            transform: scale(1.1);
        }
        
        .flag-option.selected {
            border-color: var(--accent-color);
            background: var(--accent-color);
            color: white;
            transform: scale(1.1);
        }
        
        .leaderboard-display {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            max-height: 600px;
            overflow-y: auto;
        }
        
        /* Responsive design for mobile */
        @media (max-width: 768px) {
            .leaderboard-section {
                margin-top: 2rem;
                padding: 1rem;
            }
            
            .leaderboard-header h2 {
                font-size: 2rem;
            }
            
            .submission-form {
                flex-direction: column;
                align-items: stretch;
            }
            
            .name-input {
                min-width: auto;
                width: 100%;
            }
            
            .submit-score-btn {
                width: 100%;
            }
        }
        
        .leaderboard-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            width: 350px;
            height: 400px;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
            flex-shrink: 0; /* Prevent shrinking */
        }
        
        .leaderboard-container h3 {
            color: var(--text-primary);
            font-size: 1.2rem;
            margin-bottom: 1rem;
            text-align: center;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 0.5rem;
        }
        
        .name-input-section {
            margin-bottom: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .name-input {
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.9rem;
            background: var(--bg-accent);
            color: var(--text-primary);
            text-align: center;
        }
        
        .name-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
        
        .submit-score-btn {
            padding: 0.75rem;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .submit-score-btn:hover {
            background: #1a1a1a;
            transform: translateY(-1px);
        }
        
        .submit-score-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .leaderboard {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .leaderboard-entry {
            background: var(--bg-accent);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 1rem;
            transition: all 0.2s ease;
            font-size: 0.9rem;
            margin-bottom: 0.75rem;
        }
        
        .leaderboard-entry:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        
        .leaderboard-entry .medal {
            font-size: 1.3rem;
            margin-right: 0.75rem;
        }
        
        .leaderboard-entry .country-flag {
            font-size: 1.8rem;
            margin-right: 0.5rem;
        }
        
        .leaderboard-entry .player-info {
            flex: 1;
        }
        
        .leaderboard-entry .score-info {
            text-align: right;
            min-width: 80px;
        }
        
        .atlas-minimap .leaflet-container {
            border-radius: 8px;
        }
        
        /* Custom tooltip styling */
        .country-tooltip {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            color: var(--text-primary);
            box-shadow: 0 2px 8px var(--shadow-color);
        }
        

        

        

        

        


        /* Main content */
        .main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Game modes grid */
        .game-modes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-top: 3rem;
        }

        .game-mode {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            text-align: center;
        }

        .game-mode::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--accent-color);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .game-mode:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 40px var(--shadow-color);
            border-color: var(--accent-color);
        }

        .game-mode:hover::before {
            transform: scaleX(1);
        }

        .game-mode-preview {
            margin-bottom: 1.5rem;
        }

        .preview-gif {
            width: 100%;
            height: 200px;
            object-fit: cover;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .game-mode-info {
            margin-bottom: 1.5rem;
        }

        .game-mode-info h3 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }
        
        .game-mode-info p {
            font-size: 0.9rem;
            color: var(--text-secondary);
            line-height: 1.4;
            opacity: 0.8;
            margin: 0;
        }

        .play-button {
            background: var(--accent-color);
            color:#f8fafc;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .play-button:hover {
            background: #1a1a1a;
            transform: translateY(-1px);
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 3rem 2rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* Skip Navigation Link for Accessibility */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 6px;
            background: #1e293b;
            color: white;
            padding: 8px;
            text-decoration: none;
            border-radius: 4px;
            z-index: 10000;
            transition: top 0.3s ease;
        }
        
        .skip-link:focus {
            top: 6px;
        }
        
        /* Focus styles for accessibility */
        .game-mode:focus,
        .puzzle-square:focus {
            outline: 3px solid #3b82f6;
            outline-offset: 2px;
        }
        
        .play-button:focus {
            outline: 3px solid #3b82f6;
            outline-offset: 2px;
        }
        
        /* High contrast mode support */
        @media (prefers-contrast: high) {
            .game-mode {
                border: 2px solid #000;
            }
            
            .puzzle-square {
                border: 2px solid #000;
            }
        }
        
        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            .title,
            .title span,
            .game-mode,
            .puzzle-square {
                animation: none;
                transition: none;
            }
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .title {
                font-size: 2.5rem;
            }

            .game-modes {
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                gap: 1.5rem;
            }

            .game-mode {
                padding: 1.5rem;
            }

            .main {
                padding: 1rem;
            }
        }

        @media (max-width: 480px) {
            .title {
                font-size: 2rem;
            }

            .header {
                padding: 2rem 1rem 1rem;
            }

            .game-modes {
                grid-template-columns: 1fr;
            }

            .preview-gif {
                height: 180px;
            }
        }
    </style>
</head>
<body>
    <!-- Skip Navigation Link for Accessibility -->
    <a href="#main-content" class="skip-link">Skip to main content</a>
    
    <!-- Background grid -->
    <div class="bg-grid"></div>
    
    <!-- WebGL Fluid Background -->
    <canvas id="fluid-canvas"></canvas>

    <!-- Header -->
    <header class="header" role="banner">
        <h1 class="title">
            <span>A</span>
            <span>t</span>
            <span>l</span>
            <span>a</span>
            <span>s</span>
        </h1>

        
        <div class="atlas-minimap" id="atlas-minimap">
            <div class="map-overlay">
                <div class="timer-overlay" id="timer-overlay" style="display: none;">
                    <span id="timer-text">00:00:000</span>
                </div>
                <div class="instructions-overlay" style="display: block !important;">
                    <span id="direction-text">Click any country to start</span>
                </div>
            </div>
        </div>
        
        <!-- Daily Puzzle Selector - Connected to minimap (visible by default) -->
        <div class="puzzle-selector-connected" id="puzzle-selector" role="region" aria-label="Daily Puzzle Selector">
            <div class="puzzle-square" 
                 onclick="selectPuzzle('2025-08-15')" 
                 onkeydown="if(event.key === 'Enter' || event.key === ' ') selectPuzzle('2025-08-15')"
                 id="puzzle-2025-08-15" 
                 tabindex="0"
                 role="button"
                 aria-label="Puzzle 1 - Sri Lanka (Completed)">
                <span class="puzzle-number">1</span>
            </div>
            <div class="puzzle-square" 
                 onclick="selectPuzzle('2025-08-18')" 
                 onkeydown="if(event.key === 'Enter' || event.key === ' ') selectPuzzle('2025-08-18')"
                 id="puzzle-2025-08-18" 
                 tabindex="0"
                 role="button"
                 aria-label="Puzzle 2 - South Korea (Completed)">
                <span class="puzzle-number">2</span>
            </div>
            <div class="puzzle-square current" 
                 onclick="selectPuzzle('2025-08-21')" 
                 onkeydown="if(event.key === 'Enter' || event.key === ' ') selectPuzzle('2025-08-21')"
                 id="puzzle-2025-08-21" 
                 tabindex="0"
                 role="button"
                 aria-label="Puzzle 3 - United States of America (Current)">
                <span class="puzzle-number">3</span>
            </div>
            <div class="puzzle-square locked" 
                 onclick="selectPuzzle('2025-08-24')" 
                 onkeydown="if(event.key === 'Enter' || event.key === ' ') selectPuzzle('2025-08-24')"
                 id="puzzle-2025-08-24" 
                 tabindex="0"
                 role="button"
                 aria-label="Puzzle 4 - Brazil (Locked)">
                <span class="puzzle-number">4</span>
            </div>
        </div>
        

        
        <div id="tsparticles"></div>
    </header>

    <!-- Main content -->
    <main class="main" id="main-content" role="main">
        <div class="game-modes" role="region" aria-label="Game Modes">
            <!-- Population Mode -->
            <div class="game-mode" 
                 onclick="window.location.href='population.html'" 
                 onkeydown="if(event.key === 'Enter' || event.key === ' ') window.location.href='population.html'"
                 tabindex="0"
                 role="button"
                 aria-label="Population Mode - Guess which country has more or fewer people">
                <div class="game-mode-preview">
                    <img src="gifs/populationHint.gif" alt="Population Mode Preview - Interactive preview of population guessing game" class="preview-gif">
                </div>
                <div class="game-mode-info">
                    <h3>Population</h3>
                    <p>lower or higher ?</p>
                </div>
                <button class="play-button" aria-label="Start Population Mode Game">Start</button>
            </div>

            <!-- Playground Mode -->
            <div class="game-mode" 
                 onclick="window.location.href='playground.html'" 
                 onkeydown="if(event.key === 'Enter' || event.key === ' ') window.location.href='playground.html'"
                 tabindex="0"
                 role="button"
                 aria-label="Playground Mode - Free exploration of world geography">
                <div class="game-mode-preview">
                    <img src="gifs/playgroundGif.gif" alt="Playground Mode Preview - Interactive preview of free exploration mode" class="preview-gif">
                </div>
                <div class="game-mode-info">
                    <h3>Playground</h3>
                    <p>free exploration</p>
                </div>
                <button class="play-button" aria-label="Start Playground Mode Game">Start</button>
            </div>

            <!-- Time Mode -->
            <div class="game-mode" 
                 onclick="window.location.href='time.html'" 
                 onkeydown="if(event.key === 'Enter' || event.key === ' ') window.location.href='time.html'"
                 tabindex="0"
                 role="button"
                 aria-label="Time Mode - Race against time to guess countries">
                <div class="game-mode-preview">
                    <img src="gifs/timeGif.gif" alt="Time Mode Preview - Interactive preview of time-based geography challenge" class="preview-gif">
                </div>
                <div class="game-mode-info">
                    <h3>Time</h3>
                    <p>race against time</p>
                </div>
                <button class="play-button" aria-label="Start Time Mode Game">Start</button>
            </div>

            <!-- Hint Mode -->
            <div class="game-mode" 
                 onclick="window.location.href='hint.html'" 
                 onkeydown="if(event.key === 'Enter' || event.key === ' ') window.location.href='hint.html'"
                 tabindex="0"
                 role="button"
                 aria-label="Hint Mode - Get funny clues to help guess countries">
                <div class="game-mode-preview">
                    <img src="gifs/hintGif.gif" alt="Hint Mode Preview - Interactive preview of hint-based geography game" class="preview-gif">
                </div>
                <div class="game-mode-info">
                    <h3>Hint</h3>
                    <p>get funny clues</p>
                </div>
                <button class="play-button" aria-label="Start Hint Mode Game">Start</button>
            </div>

            <!-- Football Mode -->
            <div class="game-mode" 
                 onclick="window.location.href='football.html'" 
                 onkeydown="if(event.key === 'Enter' || event.key === ' ') window.location.href='football.html'"
                 tabindex="0"
                 role="button"
                 aria-label="Football Mode - Learn geography through football clubs">
                <div class="game-mode-preview">
                    <img src="gifs/footballGif.gif" alt="Football Mode Preview - Interactive preview of football-based geography learning" class="preview-gif">
                </div>
                <div class="game-mode-info">
                    <h3>Football</h3>
                    <p>learn through football</p>
                </div>
                <button class="play-button" aria-label="Start Football Mode Game">Start</button>
            </div>

            <!-- Duel Mode -->
            <div class="game-mode" 
                 onclick="window.location.href='duel.html'" 
                 onkeydown="if(event.key === 'Enter' || event.key === ' ') window.location.href='duel.html'"
                 tabindex="0"
                 role="button"
                 aria-label="Duel Mode - Two-player competitive geography game">
                <div class="game-mode-preview">
                    <img src="gifs/duelGif.gif" alt="Duel Mode Preview - Interactive preview of two-player competitive geography game" class="preview-gif">
                </div>
                <div class="game-mode-info">
                    <h3>Duel</h3>
                    <p>two-player competitive</p>
                </div>
                <button class="play-button" aria-label="Start Duel Mode Game">Start</button>
            </div>


        </div>

        <!-- Interactive World Map Section -->
        <div class="map-section" style="margin: 3rem auto; max-width: 1200px;">
            <div class="map-container" style="position: relative; height: 500px; border-radius: 12px; overflow: hidden; border: 1px solid var(--border-color); box-shadow: 0 10px 30px var(--shadow-color);">
                <div id="world-map" style="width: 100%; height: 100%; background: #000000;">
            <div class="map-title">Wall of Emojis Map</div>
        </div>
                
                <!-- Map Info Panel -->
                <div class="map-info" style="position: absolute; top: 20px; right: 20px; background: rgba(255,255,255,0.9); padding: 15px; border-radius: 8px; border: 1px solid var(--border-color); backdrop-filter: blur(10px); max-width: 250px;">
                    <h4 style="margin: 0 0 10px 0; color: var(--text-primary); font-size: 14px;">Map Information</h4>
                    <div id="map-coordinates" style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Click on the map to see coordinates</div>
                    <div id="map-zoom" style="font-size: 12px; color: var(--text-secondary);">Zoom: 2</div>
                    <button onclick="testImageLoading()" style="margin-top: 10px; padding: 5px 10px; background: #22c55e; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Test Images</button>
                </div>
                

            </div>
        </div>
        
        <!-- Global Leaderboard Section -->
        <div class="leaderboard-section" id="leaderboard-section" style="display: block;">
            <div class="leaderboard-header">
                <p>Global Leaderboard</p>
                
            </div>
            
            <!-- Score Submission Section -->
            <div class="score-submission" id="score-submission" style="display: none;">
                <div class="submission-container">
                    <h3>üéØ Submit Your Score</h3>
                    
                    <!-- Login Status Display -->
                    <div id="login-status"></div>
                    
                    <div class="submission-form">
                        <div class="form-group">
                            <label for="player-name">Your Name:</label>
                            <input type="text" id="player-name" placeholder="Enter your name" maxlength="20" class="name-input">
                        </div>
                        <div class="form-group">
                            <label for="player-flag">Choose Your Flag:</label>
                            <div class="flag-selector" id="flag-selector">
                                <!-- Flags will be populated here -->
                            </div>
                        </div>
                        <button onclick="submitScore()" class="submit-score-btn">Submit Score</button>
                    </div>
                </div>
            </div>
            
            <!-- Leaderboard Display -->
            <div class="leaderboard-display">
                <div class="leaderboard" id="leaderboard">
                    <!-- Leaderboard will be populated here -->
                </div>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="footer" role="contentinfo">
        <p>&copy; 2025 Atlas - Interactive Geography Learning</p>
        <div class="footer-links" style="margin-top: 15px;">
            <a href="blog.html" style="color: var(--accent-color); text-decoration: none; font-weight: 500; margin-right: 20px;">
                üìù Blog
            </a>
            <a href="privacy.html" style="color: var(--accent-color); text-decoration: none; font-weight: 500; margin-right: 20px;">
                üìã Privacy Policy
            </a>
            <a href="changelog.html" style="color: var(--accent-color); text-decoration: none; font-weight: 500; margin-right: 20px;">
                üìù Changelog
            </a>
        </div>
    </footer>

    <script>
        // Add smooth hover effects
        document.querySelectorAll('.game-mode').forEach(mode => {
            mode.addEventListener('mouseenter', function() {
                this.style.transform = 'translateY(-4px)';
            });
            
            mode.addEventListener('mouseleave', function() {
                this.style.transform = 'translateY(0)';
            });
        });

        // Add click feedback
        document.querySelectorAll('.game-mode').forEach(mode => {
            mode.addEventListener('click', function() {
                // Add click animation
                this.style.transform = 'scale(0.98)';
                setTimeout(() => {
                    this.style.transform = 'scale(1)';
                }, 150);
            });
        });

        // Lightweight Mouse Trail System
        class LightMouseTrail {
            constructor() {
                this.canvas = document.getElementById('fluid-canvas');
                if (!this.canvas) {
                    console.error('Canvas not found!');
                    return;
                }
                
                this.ctx = this.canvas.getContext('2d');
                if (!this.ctx) {
                    console.error('2D context not available!');
                    return;
                }
                
                // Enable high-quality rendering
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
                
                this.mouse = { x: 0, y: 0 };
                this.trail = [];
                this.isMouseDown = false;
                
                console.log('LightMouseTrail initialized successfully!');
                
                this.resize();
                this.bindEvents();
                this.animate();
            }
            
            resize() {
                this.canvas.width = window.innerWidth * window.devicePixelRatio;
                this.canvas.height = window.innerHeight * window.devicePixelRatio;
                this.canvas.style.width = window.innerWidth + 'px';
                this.canvas.style.height = window.innerHeight + 'px';
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            }
            
            bindEvents() {
                // Smooth mouse tracking with throttling
                let ticking = false;
                
                document.addEventListener('mousemove', (e) => {
                    if (!ticking) {
                        requestAnimationFrame(() => {
                            this.updateMousePosition(e.clientX, e.clientY);
                            ticking = false;
                        });
                        ticking = true;
                    }
                });
                
                document.addEventListener('mousedown', () => {
                    this.isMouseDown = true;
                });
                
                document.addEventListener('mouseup', () => {
                    this.isMouseDown = false;
                });
                
                window.addEventListener('resize', () => this.resize());
            }
            
            updateMousePosition(x, y) {
                // Smooth interpolation for better trail quality
                const targetX = x;
                const targetY = y;
                
                // Add to trail with smooth interpolation
                this.trail.push({ 
                    x: targetX, 
                    y: targetY, 
                    time: Date.now(),
                    targetX: targetX,
                    targetY: targetY
                });
                
                if (this.trail.length > 50) {
                    this.trail.shift();
                }
            }
            
            animate() {
                // Only clear a small area around the trail, not the entire page
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw only the trail lines, nothing else
                if (this.trail.length > 1) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    
                    for (let i = 1; i < this.trail.length; i++) {
                        const point = this.trail[i];
                        const age = Date.now() - point.time;
                        const opacity = Math.max(0, 1 - age / 800);
                        
                        if (opacity > 0) {
                            this.ctx.lineTo(point.x, point.y);
                        }
                    }
                    
                    // Simple trail drawing
                    this.ctx.strokeStyle = this.isMouseDown ? 
                        'rgba(0, 0, 0, 0.8)' : 
                        'rgba(80, 80, 80, 0.6)';
                    this.ctx.lineWidth = this.isMouseDown ? 4 : 2;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    this.ctx.stroke();
                }
                
                // Simple cursor
                if (this.trail.length > 0) {
                    const lastPoint = this.trail[this.trail.length - 1];
                    const cursorSize = this.isMouseDown ? 6 : 4;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(lastPoint.x, lastPoint.y, cursorSize, 0, Math.PI * 2);
                    this.ctx.fillStyle = this.isMouseDown ? 
                        'rgba(0, 0, 0, 0.8)' : 
                        'rgba(80, 80, 80, 0.6)';
                    this.ctx.fill();
                }
                
                // Clean up old trail points
                this.trail = this.trail.filter(point => Date.now() - point.time < 800);
                
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Game variables - declare all at the top BEFORE any function calls
        let currentCountry = null;
        let gameActive = false;
        let gameTimer = null;
        let startTime = null;
        let countryCenters = {}; // Store center coordinates for each country
        let currentGameResult = null; // Store current game result
        let gameMap = null; // Leaflet map instance
        let gameGeoData = null; // GeoJSON data
        
        // Daily puzzle system - new puzzle every 3 days at 20:00
        const dailyPuzzles = {
            '2025-08-15': {
                country: 'Sri Lanka',
                date: 'August 15, 2025',
                status: 'completed'
            },
            '2025-08-18': {
                country: 'South Korea',
                date: 'August 18, 2025',
                status: 'completed'
            },
            '2025-08-21': {
                country: 'United States of America',
                date: 'August 21, 2025',
                status: 'current'
            },
            '2025-08-24': {
                country: 'Brazil',
                date: 'August 24, 2025',
                status: 'locked'
            },
            '2025-08-27': {
                country: 'Japan',
                date: 'August 27, 2025',
                status: 'locked'
            },
            '2025-08-30': {
                country: 'Australia',
                date: 'August 30, 2025',
                status: 'locked'
            },
            '2025-09-02': {
                country: 'Bhutan',
                date: 'September 2, 2025',
                status: 'locked'
            },
            '2025-09-05': {
                country: 'Mauritania',
                date: 'September 5, 2025',
                status: 'locked'
            },
            '2025-09-08': {
                country: 'Cambodia',
                date: 'September 8, 2025',
                status: 'locked'
            },
            '2025-09-11': {
                country: 'Eswatini',
                date: 'September 11, 2025',
                status: 'locked'
            },
            '2025-09-14': {
                country: 'Kyrgyzstan',
                date: 'September 14, 2025',
                status: 'locked'
            },
            '2025-09-17': {
                country: 'Lesotho',
                date: 'September 17, 2025',
                status: 'locked'
            },
            '2025-09-20': {
                country: 'Egypt',
                date: 'September 20, 2025',
                status: 'locked'
            },
            '2025-09-23': {
                country: 'Tajikistan',
                date: 'September 23, 2025',
                status: 'locked'
            },
            '2025-09-26': {
                country: 'Afghanistan',
                date: 'September 26, 2025',
                status: 'locked'
            },
            '2025-09-29': {
                country: 'Comoros',
                date: 'September 29, 2025',
                status: 'locked'
            },
            '2025-10-02': {
                country: 'Iran',
                date: 'October 2, 2025',
                status: 'locked'
            },
            '2025-10-05': {
                country: 'Djibouti',
                date: 'October 5, 2025',
                status: 'locked'
            },
            '2025-10-08': {
                country: 'Turkmenistan',
                date: 'October 8, 2025',
                status: 'locked'
            },
            '2025-10-11': {
                country: 'Guinea-Bissau',
                date: 'October 11, 2025',
                status: 'locked'
            },
            '2025-10-14': {
                country: 'Equatorial Guinea',
                date: 'October 14, 2025',
                status: 'locked'
            },
            '2025-10-17': {
                country: 'S√£o Tom√© and Pr√≠ncipe',
                date: 'October 17, 2025',
                status: 'locked'
            },
            '2025-10-20': {
                country: 'Australia',
                date: 'October 20, 2025',
                status: 'locked'
            },
            '2025-10-23': {
                country: 'Cape Verde',
                date: 'October 23, 2025',
                status: 'locked'
            },
            '2025-10-26': {
                country: 'Gambia',
                date: 'October 26, 2025',
                status: 'locked'
            },
            '2025-10-29': {
                country: 'Peru',
                date: 'October 29, 2025',
                status: 'locked'
            },
            '2025-11-01': {
                country: 'Turkey',
                date: 'November 1, 2025',
                status: 'locked'
            },
            '2025-11-04': {
                country: 'Ukraine',
                date: 'November 4, 2025',
                status: 'locked'
            },
            '2025-11-07': {
                country: 'Romania',
                date: 'November 7, 2025',
                status: 'locked'
            },
            '2025-11-10': {
                country: 'Bulgaria',
                date: 'November 10, 2025',
                status: 'locked'
            },
            '2025-11-13': {
                country: 'Croatia',
                date: 'November 13, 2025',
                status: 'locked'
            },
            '2025-11-16': {
                country: 'South Africa',
                date: 'November 16, 2025',
                status: 'locked'
            },
            '2025-11-19': {
                country: 'Slovenia',
                date: 'November 19, 2025',
                status: 'locked'
            },
            '2025-11-22': {
                country: 'Slovakia',
                date: 'November 22, 2025',
                status: 'locked'
            },
            '2025-11-25': {
                country: 'Lithuania',
                date: 'November 25, 2025',
                status: 'locked'
            },
            '2025-11-28': {
                country: 'Latvia',
                date: 'November 28, 2025',
                status: 'locked'
            },
            '2025-12-01': {
                country: 'North Korea',
                date: 'December 1, 2025',
                status: 'locked'
            },
            '2025-12-04': {
                country: 'Iceland',
                date: 'December 4, 2025',
                status: 'locked'
            },
            '2025-12-07': {
                country: 'Ireland',
                date: 'December 7, 2025',
                status: 'locked'
            },
            '2025-12-10': {
                country: 'Luxembourg',
                date: 'December 10, 2025',
                status: 'locked'
            },
            '2025-12-13': {
                country: 'Malta',
                date: 'December 13, 2025',
                status: 'locked'
            },
            '2025-12-16': {
                country: 'Cyprus',
                date: 'December 16, 2025',
                status: 'locked'
            },
            '2025-12-19': {
                country: 'Albania',
                date: 'December 19, 2025',
                status: 'locked'
            },
            '2025-12-22': {
                country: 'Macedonia',
                date: 'December 22, 2025',
                status: 'locked'
            },
            '2025-12-25': {
                country: 'Azerbaijan',
                date: 'December 25, 2025',
                status: 'locked'
            },
            '2025-12-28': {
                country: 'Bosnia and Herzegovina',
                date: 'December 28, 2025',
                status: 'locked'
            },
            '2025-12-31': {
                country: 'Moldova',
                date: 'December 31, 2025',
                status: 'locked'
            }
        };
        
        // Get today's date in YYYY-MM-DD format
        function getTodayDate() {
            const today = new Date();
            return today.toISOString().split('T')[0];
        }
        
        // Get current puzzle
        function getCurrentPuzzle() {
            const today = getTodayDate();
            return dailyPuzzles[today] || dailyPuzzles['2025-08-21']; // Fallback to current
        }
        
        // Check if puzzle is completed
        function isPuzzleCompleted(date) {
            const puzzle = dailyPuzzles[date];
            if (!puzzle) return false;
            
            // Check localStorage for completion status
            const completedPuzzles = JSON.parse(localStorage.getItem('completedPuzzles') || '{}');
            return completedPuzzles[date] === true;
        }
        
        // Mark puzzle as completed
        function markPuzzleCompleted(date) {
            const completedPuzzles = JSON.parse(localStorage.getItem('completedPuzzles') || '{}');
            completedPuzzles[date] = true;
            localStorage.setItem('completedPuzzles', JSON.stringify(completedPuzzles));
        }
        
        // Function to check if puzzle has been submitted to leaderboard
        async function isPuzzleSubmittedToLeaderboard(country, playerName) {
            if (!supabase || !playerName) return false;
            
            try {
                const { data: existingScores, error } = await supabase
                    .from('leaderboard')
                    .select('*')
                    .eq('player_name', playerName)
                    .eq('country', country);
                
                if (error) {
                    console.error('Error checking leaderboard submission:', error);
                    return false;
                }
                
                return existingScores && existingScores.length > 0;
            } catch (error) {
                console.error('Error checking leaderboard submission:', error);
                return false;
            }
        }
        
        // Function to check if any puzzle has been completed
        function hasAnyPuzzleBeenCompleted() {
            const completedPuzzles = JSON.parse(localStorage.getItem('completedPuzzles') || '{}');
            return Object.values(completedPuzzles).some(completed => completed === true);
        }
        
        // Function to generate a unique device identifier
        function generateDeviceId() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillText('Device fingerprint', 2, 2);
            
            const fingerprint = [
                navigator.userAgent,
                navigator.language,
                screen.width + 'x' + screen.height,
                new Date().getTimezoneOffset(),
                canvas.toDataURL()
            ].join('|');
            
            // Create a hash of the fingerprint
            let hash = 0;
            for (let i = 0; i < fingerprint.length; i++) {
                const char = fingerprint.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            
            return Math.abs(hash).toString(36);
        }
        
        // Function to get or create device ID
        function getDeviceId() {
            let deviceId = localStorage.getItem('deviceId');
            if (!deviceId) {
                deviceId = generateDeviceId();
                localStorage.setItem('deviceId', deviceId);
            }
            return deviceId;
        }
        
        // Function to save user login info
        function saveUserLogin(playerName, playerFlag) {
            const userData = {
                playerName: playerName,
                playerFlag: playerFlag,
                deviceId: getDeviceId(),
                loginTime: Date.now()
            };
            localStorage.setItem('userLogin', JSON.stringify(userData));
            
            // Update login status display
            showLoginStatus();
            
            // Update submission form visibility
            updateSubmissionFormVisibility();
        }
        
        // Function to get saved user login info
        function getUserLogin() {
            const userData = localStorage.getItem('userLogin');
            if (userData) {
                try {
                    return JSON.parse(userData);
                } catch (e) {
                    return null;
                }
            }
            return null;
        }
        
        // Function to check if user is logged in
        function isUserLoggedIn() {
            const userData = getUserLogin();
            if (!userData) return false;
            
            // Check if device ID matches (prevent multiple logins from different devices)
            if (userData.deviceId !== getDeviceId()) {
                return false;
            }
            
            // Check if login is not too old (optional: expire after 30 days)
            const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
            if (userData.loginTime < thirtyDaysAgo) {
                return false;
            }
            
            return true;
        }
        
        // Function to clear user login (no longer used - removed logout functionality)
        function clearUserLogin() {
            localStorage.removeItem('userLogin');
            // Update UI to show login form again
            showLoginStatus();
            updateSubmissionFormVisibility();
        }
        
        // Function to show current login status
        function showLoginStatus() {
            const userLogin = getUserLogin();
            const loginStatus = document.getElementById('login-status');
            
            if (loginStatus) {
                if (userLogin) {
                    loginStatus.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px; padding: 10px; background: #f3f4f6; border-radius: 6px; border: 1px solid #d1d5db;">
                            <span>Logged in as: <strong>${userLogin.playerName}</strong> ${userLogin.playerFlag}</span>
                            <span style="margin-left: auto; font-size: 0.8rem;">
                                <a href="#" onclick="clearUserLogin(); return false;" style="color: #6b7280; text-decoration: underline;">Change Account</a>
                            </span>
                        </div>
                    `;
                } else {
                    loginStatus.innerHTML = `
                        <div style="margin-bottom: 15px; padding: 10px; background: #fef3c7; border-radius: 6px; border: 1px solid #f59e0b; color: #92400e;">
                            <strong>First time user:</strong> Enter your name and select a flag below. This will be saved for future games.
                        </div>
                    `;
                }
            }
        }
        
        // Function to update submission form visibility based on login status
        function updateSubmissionFormVisibility() {
            const userLogin = getUserLogin();
            const nameInput = document.getElementById('player-name');
            const flagSelector = document.getElementById('flag-selector');
            const submitBtn = document.querySelector('.submit-score-btn');
            
            if (userLogin && isUserLoggedIn()) {
                // User is logged in - hide inputs and auto-fill
                if (nameInput) nameInput.style.display = 'none';
                if (flagSelector) flagSelector.style.display = 'none';
                
                // Update submit button text
                if (submitBtn) submitBtn.textContent = 'Submit Score';
                
                // Auto-fill the hidden inputs with saved values
                if (nameInput) nameInput.value = userLogin.playerName;
                if (window.selectedPlayerFlag !== userLogin.playerFlag) {
                    window.selectedPlayerFlag = userLogin.playerFlag;
                }
            } else {
                // User is not logged in - show inputs
                if (nameInput) nameInput.style.display = 'block';
                if (flagSelector) flagSelector.style.display = 'block';
                
                // Clear inputs
                if (nameInput) nameInput.value = '';
                if (window.selectedPlayerFlag) window.selectedPlayerFlag = '';
            }
        }
        
        // Function to check if puzzle selector should be visible
        function shouldShowPuzzleSelector() {
            // Check if user has explicitly chosen to always show
            const alwaysShow = localStorage.getItem('alwaysShowPuzzleSelector') === 'true';
            if (alwaysShow) {
                return true;
            }
            
            // Always show if any puzzle has been completed
            if (hasAnyPuzzleBeenCompleted()) {
                return true;
            }
            
            // Show by default for new users
            return true;
        }
        
        // Get next puzzle date (every 3 days at 20:00)
        function getNextPuzzleDate() {
            const now = new Date();
            const currentHour = now.getHours();
            
            // If it's before 20:00 today, next puzzle is today at 20:00
            // If it's after 20:00 today, next puzzle is in 3 days at 20:00
            let nextDate = new Date(now);
            
            if (currentHour < 20) {
                // Today at 20:00
                nextDate.setHours(20, 0, 0, 0);
            } else {
                // Next puzzle in 3 days at 20:00
                nextDate.setDate(now.getDate() + 3);
                nextDate.setHours(20, 0, 0, 0);
            }
            
            return nextDate;
        }
        
        // Calculate time until next puzzle
        function getTimeUntilNextPuzzle() {
            const now = new Date();
            const nextPuzzle = getNextPuzzleDate();
            
            return nextPuzzle.getTime() - now.getTime();
        }
        
        // Country flag mapping
        const countryFlags = {
                    'Afghanistan': 'üá¶üá´',
            'Albania': 'üá¶üá±',
            'Algeria': 'üá©üáø',
            'Andorra': 'üá¶üá©',
            'Angola': 'üá¶üá¥',
            'Antigua and Barbuda': 'üá¶üá¨',
            'Argentina': 'üá¶üá∑',
            'Armenia': 'üá¶üá≤',
            'Australia': 'üá¶üá∫',
            'Austria': 'üá¶üáπ',
            'Azerbaijan': 'üá¶üáø',
            'Bahamas': 'üáßüá∏',
            'Bahrain': 'üáßüá≠',
            'Bangladesh': 'üáßüá©',
            'Barbados': 'üáßüáß',
            'Belarus': 'üáßüáæ',
            'Belgium': 'üáßüá™',
            'Belize': 'üáßüáø',
            'Benin': 'üáßüáØ',
            'Bhutan': 'üáßüáπ',
            'Bolivia': 'üáßüá¥',
            'Bosnia and Herzegovina': 'üáßüá¶',
            'Botswana': 'üáßüáº',
            'Brazil': 'üáßüá∑',
            'Brunei': 'üáßüá≥',
            'Bulgaria': 'üáßüá¨',
            'Burkina Faso': 'üáßüá´',
            'Burundi': 'üáßüáÆ',
            'Cabo Verde': 'üá®üáª',
            'Cambodia': 'üá∞üá≠',
            'Cameroon': 'üá®üá≤',
            'Canada': 'üá®üá¶',
            'Central African Republic': 'üá®üá´',
            'Chad': 'üáπüá©',
            'Chile': 'üá®üá±',
            'China': 'üá®üá≥',
            'Colombia': 'üá®üá¥',
            'Comoros': 'üá∞üá≤',
            'Congo (Congo-Brazzaville)': 'üá®üá¨',
            'Congo (Democratic Republic)': 'üá®üá©',
            'Costa Rica': 'üá®üá∑',
            'Croatia': 'üá≠üá∑',
            'Cuba': 'üá®üá∫',
            'Cyprus': 'üá®üáæ',
            'Czech Republic': 'üá®üáø',
            'Denmark': 'üá©üá∞',
            'Djibouti': 'üá©üáØ',
            'Dominica': 'üá©üá≤',
            'Dominican Republic': 'üá©üá¥',
            'Ecuador': 'üá™üá®',
            'Egypt': 'üá™üá¨',
            'El Salvador': 'üá∏üáª',
            'Equatorial Guinea': 'üá¨üá∂',
            'Eritrea': 'üá™üá∑',
            'Estonia': 'üá™üá™',
            'Eswatini': 'üá∏üáø',
            'Ethiopia': 'üá™üáπ',
            'Fiji': 'üá´üáØ',
            'Finland': 'üá´üáÆ',
            'France': 'üá´üá∑',
            'Gabon': 'üá¨üá¶',
            'Gambia': 'üá¨üá≤',
            'Georgia': 'üá¨üá™',
            'Germany': 'üá©üá™',
            'Ghana': 'üá¨üá≠',
            'Greece': 'üá¨üá∑',
            'Grenada': 'üá¨üá©',
            'Guatemala': 'üá¨üáπ',
            'Guinea': 'üá¨üá≥',
            'Guinea-Bissau': 'üá¨üáº',
            'Guyana': 'üá¨üáæ',
            'Haiti': 'üá≠üáπ',
            'Honduras': 'üá≠üá≥',
            'Hungary': 'üá≠üá∫',
            'Iceland': 'üáÆüá∏',
            'India': 'üáÆüá≥',
            'Indonesia': 'üáÆüá©',
            'Iran': 'üáÆüá∑',
            'Iraq': 'üáÆüá∂',
            'Ireland': 'üáÆüá™',
            'Israel': 'üáÆüá±',
            'Italy': 'üáÆüáπ',
            'Jamaica': 'üáØüá≤',
            'Japan': 'üáØüáµ',
            'Jordan': 'üáØüá¥',
            'Kazakhstan': 'üá∞üáø',
            'Kenya': 'üá∞üá™',
            'Kiribati': 'üá∞üáÆ',
            'Kuwait': 'üá∞üáº',
            'Kyrgyzstan': 'üá∞üá¨',
            'Laos': 'üá±üá¶',
            'Latvia': 'üá±üáª',
            'Lebanon': 'üá±üáß',
            'Lesotho': 'üá±üá∏',
            'Liberia': 'üá±üá∑',
            'Libya': 'üá±üáæ',
            'Liechtenstein': 'üá±üáÆ',
            'Lithuania': 'üá±üáπ',
            'Luxembourg': 'üá±üá∫',
            'Madagascar': 'üá≤üá¨',
            'Malawi': 'üá≤üáº',
            'Malaysia': 'üá≤üáæ',
            'Maldives': 'üá≤üáª',
            'Mali': 'üá≤üá±',
            'Malta': 'üá≤üáπ',
            'Marshall Islands': 'üá≤üá≠',
            'Mauritania': 'üá≤üá∑',
            'Mauritius': 'üá≤üá∫',
            'Mexico': 'üá≤üáΩ',
            'Micronesia': 'üá´üá≤',
            'Moldova': 'üá≤üá©',
            'Monaco': 'üá≤üá®',
            'Mongolia': 'üá≤üá≥',
            'Montenegro': 'üá≤üá™',
            'Morocco': 'üá≤üá¶',
            'Mozambique': 'üá≤üáø',
            'Myanmar': 'üá≤üá≤',
            'Namibia': 'üá≥üá¶',
            'Nauru': 'üá≥üá∑',
            'Nepal': 'üá≥üáµ',
            'Netherlands': 'üá≥üá±',
            'New Zealand': 'üá≥üáø',
            'Nicaragua': 'üá≥üáÆ',
            'Niger': 'üá≥üá™',
            'Nigeria': 'üá≥üá¨',
            'North Korea': 'üá∞üáµ',
            'North Macedonia': 'üá≤üá∞',
            'Norway': 'üá≥üá¥',
            'Oman': 'üá¥üá≤',
            'Pakistan': 'üáµüá∞',
            'Palau': 'üáµüáº',
            'Palestine': 'üáµüá∏',
            'Panama': 'üáµüá¶',
            'Papua New Guinea': 'üáµüá¨',
            'Paraguay': 'üáµüáæ',
            'Peru': 'üáµüá™',
            'Philippines': 'üáµüá≠',
            'Poland': 'üáµüá±',
            'Portugal': 'üáµüáπ',
            'Qatar': 'üá∂üá¶',
            'Romania': 'üá∑üá¥',
            'Russia': 'üá∑üá∫',
            'Rwanda': 'üá∑üáº',
            'Saint Kitts and Nevis': 'üá∞üá≥',
            'Saint Lucia': 'üá±üá®',
            'Saint Vincent and the Grenadines': 'üáªüá®',
            'Samoa': 'üáºüá∏',
            'San Marino': 'üá∏üá≤',
            'Sao Tome and Principe': 'üá∏üáπ',
            'Saudi Arabia': 'üá∏üá¶',
            'Senegal': 'üá∏üá≥',
            'Serbia': 'üá∑üá∏',
            'Seychelles': 'üá∏üá®',
            'Sierra Leone': 'üá∏üá±',
            'Singapore': 'üá∏üá¨',
            'Slovakia': 'üá∏üá∞',
            'Slovenia': 'üá∏üáÆ',
            'Solomon Islands': 'üá∏üáß',
            'Somalia': 'üá∏üá¥',
            'South Africa': 'üáøüá¶',
            'South Korea': 'üá∞üá∑',
            'South Sudan': 'üá∏üá∏',
            'Spain': 'üá™üá∏',
            'Sri Lanka': 'üá±üá∞',
            'Sudan': 'üá∏üá©',
            'Suriname': 'üá∏üá∑',
            'Sweden': 'üá∏üá™',
            'Switzerland': 'üá®üá≠',
            'Syria': 'üá∏üáæ',
            'Taiwan': 'üáπüáº',
            'Tajikistan': 'üáπüáØ',
            'Tanzania': 'üáπüáø',
            'Thailand': 'üáπüá≠',
            'Timor-Leste': 'üáπüá±',
            'Togo': 'üáπüá¨',
            'Tonga': 'üáπüá¥',
            'Trinidad and Tobago': 'üáπüáπ',
            'Tunisia': 'üáπüá≥',
            'Turkey': 'üáπüá∑',
            'Turkmenistan': 'üáπüá≤',
            'Tuvalu': 'üáπüáª',
            'Uganda': 'üá∫üá¨',
            'Ukraine': 'üá∫üá¶',
            'United Arab Emirates': 'üá¶üá™',
            'United Kingdom': 'üá¨üáß',
            'United States of America': 'üá∫üá∏',
            'Uruguay': 'üá∫üáæ',
            'Uzbekistan': 'üá∫üáø',
            'Vanuatu': 'üáªüá∫',
            'Vatican City': 'üáªüá¶',
            'Venezuela': 'üáªüá™',
            'Vietnam': 'üáªüá≥',
            'Yemen': 'üáæüá™',
            'Zambia': 'üáøüá≤',
            'Zimbabwe': 'üáøüáº'
        };
        
        // Function to get country flag emoji
        function getCountryFlag(countryName) {
            return countryFlags[countryName] || 'üåç'; // Default to world emoji if no flag found
        }
        
        // Function to calculate score based on time (faster = higher score)
        function calculateScore(timeInSeconds) {
            // Base score: 1000 points
            // Time penalty: -10 points per second
            // Minimum score: 100 points
            const baseScore = 1000;
            const timePenalty = timeInSeconds * 10;
            const finalScore = Math.max(baseScore - timePenalty, 100);
            return finalScore;
        }
        
        // Function to populate flag selector
        function populateFlagSelector() {
            const flagSelector = document.getElementById('flag-selector');
            if (!flagSelector) return;
            
            flagSelector.innerHTML = '';
            
            // Add all available flags
            Object.values(countryFlags).forEach(flag => {
                const flagOption = document.createElement('div');
                flagOption.className = 'flag-option';
                flagOption.textContent = flag;
                flagOption.onclick = () => selectFlag(flag, flagOption);
                flagSelector.appendChild(flagOption);
            });
            
            // Auto-select first flag as default
            const firstFlag = flagSelector.querySelector('.flag-option');
            if (firstFlag) {
                selectFlag(firstFlag.textContent, firstFlag);
            }
        }
        
        // Function to handle flag selection
        function selectFlag(flag, element) {
            // Remove previous selection
            const allFlags = document.querySelectorAll('.flag-option');
            allFlags.forEach(f => f.classList.remove('selected'));
            
            // Select new flag
            element.classList.add('selected');
            
            // Store selected flag
            window.selectedPlayerFlag = flag;
        }
        
        // Function to get total score for a player
        function getPlayerTotalScore(playerName) {
            if (!window.playerScores) return 0;
            return window.playerScores[playerName] || 0;
        }
        
        // Function to select a puzzle
        function selectPuzzle(date) {
            const puzzle = dailyPuzzles[date];
            if (!puzzle) return;
            
            // Check if puzzle is locked (future date)
            if (date > getTodayDate()) {
                // Show countdown for locked puzzle instead of alert
                showLockedPuzzleCountdown(date, puzzle);
                return;
            }
            
            // Allow replaying puzzles - we'll just prevent duplicate submissions
            // No need to check if puzzle is completed here
            
            // Set the selected puzzle
            currentCountry = puzzle.country;
            
            // Update UI to show selected puzzle
            updatePuzzleSelection(date);
            
            // Reset game state but keep the selected country
            resetGame(true);
            
            // Update map instructions
            const directionText = document.getElementById('direction-text');
            if (directionText) {
                directionText.textContent = `Click to start guessing`;
            }
            
            console.log(`Selected puzzle: ${puzzle.country} for ${puzzle.date}`);
            console.log(`Current target country set to: ${currentCountry}`);
            console.log(`Puzzle object:`, puzzle);
        }
        
        // Function to update puzzle selection UI
        function updatePuzzleSelection(selectedDate) {
            // Remove current selection from all squares
            document.querySelectorAll('.puzzle-square').forEach(square => {
                square.classList.remove('selected');
            });
            
            // Add selection to clicked square
            const selectedSquare = document.getElementById(`puzzle-${selectedDate}`);
            if (selectedSquare) {
                selectedSquare.classList.add('selected');
            }
        }
        
        // Function to update puzzle completion status
        async function updatePuzzleStatus() {
            const today = getTodayDate();
            
            // Get current player name for leaderboard submission check
            const playerNameInput = document.getElementById('player-name');
            const currentPlayerName = playerNameInput ? playerNameInput.value.trim() : '';
            
            for (const date of Object.keys(dailyPuzzles)) {
                const square = document.getElementById(`puzzle-${date}`);
                
                if (square) {
                    if (isPuzzleCompleted(date)) {
                        // Check if this puzzle has been submitted to leaderboard
                        const puzzle = dailyPuzzles[date];
                        let isSubmitted = false;
                        
                        if (currentPlayerName && puzzle) {
                            isSubmitted = await isPuzzleSubmittedToLeaderboard(puzzle.country, currentPlayerName);
                        }
                        
                        if (isSubmitted) {
                            square.classList.add('submitted');
                            square.classList.remove('completed', 'current', 'locked');
                            square.innerHTML = `<span class="puzzle-number">üèÜ</span>`;
                        } else {
                            square.classList.add('completed');
                            square.classList.remove('submitted', 'current', 'locked');
                            square.innerHTML = `<span class="puzzle-number">‚úÖ</span>`;
                        }
                    } else if (date === today) {
                        square.classList.add('current');
                        square.classList.remove('completed', 'submitted', 'locked');
                        // Reset the square content to show current puzzle
                        square.innerHTML = `<span class="puzzle-number">3</span>`;
                    } else if (date < today) {
                        square.classList.remove('completed', 'submitted', 'current', 'locked');
                        // Reset the square content to show available puzzle
                        const puzzle = dailyPuzzles[date];
                        if (puzzle) {
                            const puzzleNumber = Object.keys(dailyPuzzles).indexOf(date) + 1;
                            square.innerHTML = `<span class="puzzle-number">${puzzleNumber}</span>`;
                        }
                    } else {
                        square.classList.add('locked');
                        square.classList.remove('completed', 'submitted', 'current');
                        // Show locked puzzle number (but will be replaced by countdown if it's the next puzzle)
                        const puzzle = dailyPuzzles[date];
                        if (puzzle) {
                            const puzzleNumber = Object.keys(dailyPuzzles).indexOf(date) + 1;
                            square.innerHTML = `<span class="puzzle-number">${puzzleNumber}</span>`;
                        }
                    }
                }
            }
            

            
            // Check if any new puzzles should be unlocked
            checkForNewPuzzles();
        }
        
        // Function to check if new puzzles should be unlocked
        function checkForNewPuzzles() {
            const now = new Date();
            const currentHour = now.getHours();
            
            Object.keys(dailyPuzzles).forEach(date => {
                const puzzleDate = new Date(date);
                const puzzleHour = puzzleDate.getHours();
                
                // If puzzle date has passed and it's after 20:00, unlock it
                if (puzzleDate <= now && puzzleHour <= 20) {
                    const square = document.getElementById(`puzzle-${date}`);
                    if (square && square.classList.contains('locked')) {
                        square.classList.remove('locked');
                        const puzzleNumber = Object.keys(dailyPuzzles).indexOf(date) + 1;
                        square.innerHTML = `<span class="puzzle-number">${puzzleNumber}</span>`;
                        console.log(`New puzzle unlocked: ${dailyPuzzles[date].country}`);
                    }
                }
            });
        }
        

        
        // Supabase Configuration
        const SUPABASE_URL = 'https://muqzrfdryzcrsjkpinrx.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im11cXpyZmRyeXpjcnNqa3BpbnJ4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ5NDM1MjIsImV4cCI6MjA3MDUxOTUyMn0.w7mEQDH8vHrl_PKwWsdwMl0Aa05fVb8IAjZRB9u0Yq8';
        let supabase = null; // Will be initialized after library loads
        

        
        async function initAtlasMinimap() {
            try {
                console.log('Starting initAtlasMinimap...');
                console.log('Current gameMap value:', gameMap);
                
                // Wait for Leaflet to be available
                if (typeof L === 'undefined') {
                    console.log('Leaflet not available, retrying...');
                    setTimeout(initAtlasMinimap, 100);
                    return;
                }
                
                const minimap = document.getElementById('atlas-minimap');
                if (!minimap) {
                    console.log('Minimap element not found');
                    return;
                }
                
                console.log('Minimap element found, proceeding...');
                
                // Store the overlay elements before clearing
                const mapOverlay = minimap.querySelector('.map-overlay');
                
                // Clear any existing content
                minimap.innerHTML = '';
                
                // Restore the overlay elements
                if (mapOverlay) {
                    minimap.appendChild(mapOverlay);
                }
                
                console.log('About to create Leaflet map...');
                
                // Initialize the map
                gameMap = L.map('atlas-minimap', {
                    center: [20, 0],
                    zoom: 2,
                    zoomControl: false,
                    attributionControl: false,
                    dragging: true,
                    touchZoom: true,
                    scrollWheelZoom: false,
                    doubleClickZoom: false,
                    boxZoom: false,
                    keyboard: false
                });
                
                console.log('Leaflet map created successfully:', gameMap);
                
                // Add OpenStreetMap tiles
                if (gameMap) {
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        maxZoom: 19,
                        attribution: '¬© OpenStreetMap contributors'
                    }).addTo(gameMap);
                }
                
                // Load and display GeoJSON countries
                try {
                    const response = await fetch('countries.geojson');
                    gameGeoData = await response.json();
                    
                    // Calculate center coordinates for each country
                    gameGeoData.features.forEach(feature => {
                        const countryName = feature.properties.name || feature.properties.ADMIN || feature.properties.NAME || 'Unknown';
                        const coordinates = feature.geometry.coordinates;
                        
                        if (feature.geometry.type === 'Polygon') {
                            // For single polygon, calculate centroid
                            const centroid = calculatePolygonCentroid(coordinates[0]);
                            countryCenters[countryName] = { lat: centroid[1], lng: centroid[0] };
                        } else if (feature.geometry.type === 'MultiPolygon') {
                            // For multiple polygons, calculate centroid of the largest one
                            let largestArea = 0;
                            let largestCentroid = null;
                            
                            coordinates.forEach(polygon => {
                                const area = calculatePolygonArea(polygon[0]);
                                if (area > largestArea) {
                                    largestArea = area;
                                    largestCentroid = calculatePolygonCentroid(polygon[0]);
                                }
                            });
                            
                            if (largestCentroid) {
                                countryCenters[countryName] = { lat: largestCentroid[1], lng: largestCentroid[0] };
                            }
                        }
                    });
                    
                    // Style for countries
                    const countryStyle = {
                        fillColor: '#e2e8f0',
                        weight: 1,
                        opacity: 0.8,
                        color: '#475569',
                        fillOpacity: 0.3
                    };
                    
                    // Add countries to map - ensure gameMap is ready
                    if (gameMap) {
                        L.geoJSON(gameGeoData, {
                            style: countryStyle,
                            onEachFeature: function(feature, layer) {
                                // Add country name on hover
                                layer.bindTooltip(feature.properties.name || 'Unknown Country', {
                                    permanent: false,
                                    direction: 'top',
                                    className: 'country-tooltip'
                                });
                                
                                // Store layer reference for game interaction
                                layer.feature = feature;
                            }
                        }).addTo(gameMap);
                        
                        console.log('GeoJSON countries loaded successfully');
                        console.log('Country centers calculated:', Object.keys(countryCenters).length);
                    }
                    
                } catch (geoError) {
                    console.warn('Could not load GeoJSON, showing basic map:', geoError);
                    // Map will still work without GeoJSON overlay
                }
                
                // Fit map to container after a short delay
                setTimeout(() => {
                    if (gameMap && typeof gameMap.invalidateSize === 'function') {
                        gameMap.invalidateSize();
                        
                        // Initialize the hint game after map is fully ready
                        initHintGame();
                    } else {
                        console.log('Map not ready in setTimeout, retrying...');
                        setTimeout(() => {
                            if (gameMap && typeof gameMap.invalidateSize === 'function') {
                                gameMap.invalidateSize();
                                initHintGame();
                            }
                        }, 100);
                    }
                }, 100);
                
                console.log('Real Atlas mini-map initialized with OpenStreetMap');
                
            } catch (error) {
                console.error('Error initializing mini-map:', error);
                const minimap = document.getElementById('atlas-minimap');
                if (minimap) {
                    minimap.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">üåç Interactive World Map</div>';
                }
            }
        }
        
        // Initialize mouse trail system when page loads
        window.addEventListener('load', () => {
            console.log('Page loaded, initializing light mouse trail...');
            new LightMouseTrail();
            
            // Initialize Supabase client after library loads
            if (window.supabase) {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('Supabase client initialized successfully');
            } else {
                console.error('Supabase library not loaded');
            }
            
            // Initialize Atlas mini-map (this will also initialize the hint game)
            initAtlasMinimap();
            
            // Load the leaderboard data immediately when page loads
            loadGlobalLeaderboard();
            
            // Initialize daily puzzle system
            updatePuzzleStatus();
            
            // Show puzzle selector based on completion status
            const puzzleSelector = document.getElementById('puzzle-selector');
            if (puzzleSelector && shouldShowPuzzleSelector()) {
                puzzleSelector.style.display = 'flex';
                console.log('Puzzle selector shown on page load');
            }
            
            // Set default puzzle to today's puzzle
            const today = getTodayDate();
            if (dailyPuzzles[today]) {
                selectPuzzle(today);
            } else {
                // Fallback to current puzzle
                selectPuzzle('2025-08-21');
            }
            
            // Show login status
            showLoginStatus();
            
            // Update submission form visibility
            updateSubmissionFormVisibility();
            
            // Populate flag selector for initial display
            populateFlagSelector();
        });
        
        function initHintGame() {
            // Add click handler to map for guessing
            if (gameMap && typeof gameMap.on === 'function') {
                gameMap.on('click', handleMapClick);
                console.log('Map click handler initialized');
            } else {
                console.log('Map not ready yet, retrying in 100ms...');
                setTimeout(initHintGame, 100);
            }
        }
        
        function startNewGame() {
            // Don't override currentCountry - use the one already set by selectPuzzle
            // currentCountry should already be set to the selected puzzle's country
            console.log('startNewGame called - currentCountry before:', currentCountry);
            
            if (!currentCountry) {
                // Fallback to default if somehow no country is selected
                currentCountry = 'United States of America';
                console.warn('No country selected, using default fallback');
            }
            
            console.log('startNewGame - currentCountry after:', currentCountry);
            
            gameActive = true;
            startTime = Date.now();
            
            // Reset flag selection for new game
            window.selectedPlayerFlag = null;
            const selectedFlags = document.querySelectorAll('.flag-option.selected');
            selectedFlags.forEach(flag => flag.classList.remove('selected'));
            
            // Reset game result when starting a new game
            currentGameResult = null;
            
            // Update UI with safety checks
            const timerOverlay = document.getElementById('timer-overlay');
            const directionText = document.getElementById('direction-text');
            const instructionsOverlay = document.querySelector('.instructions-overlay');
            
            if (timerOverlay) timerOverlay.style.display = 'block';
            if (directionText) directionText.textContent = 'Keep guessing!';
            if (instructionsOverlay) instructionsOverlay.classList.add('game-started');
            
            // Start timer
            startTimer();
            
            // Reset map styling
            resetMapStyling();
            
            console.log('New game started. Country:', currentCountry);
            console.log('Game state - currentCountry:', currentCountry, 'gameActive:', gameActive);
        }
        
        function startTimer() {
            gameTimer = setInterval(() => {
                if (gameActive) {
                    const elapsed = Date.now() - startTime;
                    const seconds = Math.floor(elapsed / 1000);
                    const minutes = Math.floor(seconds / 60);
                    const remainingSeconds = seconds % 60;
                    const milliseconds = elapsed % 1000;
                    
                    const timeString = `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
                    const timerText = document.getElementById('timer-text');
                    if (timerText) {
                        timerText.textContent = timeString;
                    }
                }
            }, 10); // Update every 10ms for smooth millisecond display
        }
        
        // Calculate distance between two points using Haversine formula
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in kilometers
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // Get color based on distance
        function getDistanceColor(distance) {
            if (distance < 500) return '#166534'; // Extremely close - Very dark green
            if (distance < 1000) return '#22c55e'; // Very close - Dark green
            if (distance < 2000) return '#4ade80'; // Close - Light green
            if (distance < 3000) return '#a3e635'; // Medium close - Lime green
            if (distance < 5000) return '#fbbf24'; // Medium - Yellow
            if (distance < 7000) return '#f97316'; // Far - Orange
            if (distance < 9000) return '#ef4444'; // Very far - Red
            if (distance < 12000) return '#dc2626'; // Extremely far - Dark red
            return '#7f1d1d'; // Ultra far - Very dark red
        }
        
        function handleMapClick(e) {
            const clickedLat = e.latlng.lat;
            const clickedLng = e.latlng.lng;
            
            // Find which country was clicked
            const clickedCountry = findCountryAtPoint(clickedLat, clickedLng);
            
            if (clickedCountry) {
                // If game not started, start it
                if (!gameActive) {
                    startNewGame();
                    return;
                }
                
                console.log(`Clicked: ${clickedCountry}, Target: ${currentCountry}`);
                if (clickedCountry === currentCountry) {
                    // Correct guess!
                    correctGuess(clickedCountry);
                } else {
                    // Wrong guess - color based on distance
                    const targetCenter = countryCenters[currentCountry];
                    if (targetCenter) {
                        const distance = calculateDistance(
                            clickedLat, clickedLng,
                            targetCenter.lat, targetCenter.lng
                        );
                        const color = getDistanceColor(distance);
                        
                        // Color the clicked country based on distance
                        highlightCountry(clickedCountry, color);
                        
                        // Show distance info
                        showDistanceInfo(clickedCountry, distance);
                        
                        // Show direction arrow
                        showDirectionArrow(clickedLat, clickedLng, targetCenter.lat, targetCenter.lng);
                    }
                }
            }
        }
        
        function findCountryAtPoint(lat, lng) {
            if (!gameGeoData) return null;
            
            for (let feature of gameGeoData.features) {
                if (feature.geometry && feature.geometry.type === 'Polygon') {
                    if (isPointInPolygon([lng, lat], feature.geometry.coordinates[0])) {
                        return feature.properties.name;
                    }
                } else if (feature.geometry && feature.geometry.type === 'MultiPolygon') {
                    for (let polygon of feature.geometry.coordinates) {
                        if (isPointInPolygon([lng, lat], polygon[0])) {
                            return feature.properties.name;
                        }
                    }
                }
            }
            return null;
        }
        
        function isPointInPolygon(point, polygon) {
            const x = point[0], y = point[1];
            let inside = false;
            
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i][0], yi = polygon[i][1];
                const xj = polygon[j][0], yj = polygon[j][1];
                
                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }
        
        function correctGuess(country) {
            // Stop timer
            clearInterval(gameTimer);
            gameActive = false;
            
            // Calculate final time
            const finalTime = Date.now() - startTime;
            const timeInSeconds = Math.floor(finalTime / 1000);
            
            // Calculate score based on time
            const score = calculateScore(timeInSeconds);
            
            // Mark the selected puzzle as completed
            // Find which puzzle date corresponds to the current country
            let puzzleDateToMark = null;
            for (const [date, puzzle] of Object.entries(dailyPuzzles)) {
                if (puzzle.country === currentCountry) {
                    puzzleDateToMark = date;
                    break;
                }
            }
            
            if (puzzleDateToMark) {
                markPuzzleCompleted(puzzleDateToMark);
                
                // Start countdown for next puzzle immediately

            }
            
            // Store current game result
            currentGameResult = {
                country: country,
                time: timeInSeconds,
                score: score,
                date: new Date().toLocaleDateString(),
                timestamp: Date.now()
            };
            
            // Highlight correct country on map
            highlightCountry(country, '#10b981');
            
            // Show success message in console
            console.log(`üéâ Correct! It's ${country}! Time: ${timeInSeconds}s`);
            
            // Trigger confetti effect
            triggerConfetti();
            
            // Ensure puzzle selector is visible when puzzle is completed
            const puzzleSelector = document.getElementById('puzzle-selector');
            if (puzzleSelector) {
                puzzleSelector.style.display = 'flex';
                console.log('Puzzle selector confirmed visible after completion');
            }
            
            // Show results containers
            showResults();
            
            // Show restart instructions
            setTimeout(() => {
                const directionText = document.getElementById('direction-text');
                if (directionText) {
                    directionText.textContent = 'Click any country to play again';
                }
                
                // Don't reset currentGameResult here - it will be reset after score submission
            }, 2000);
            
            console.log('Correct guess!');
        }
        
        function showDistanceInfo(country, distance) {
            console.log(`${country} is ${Math.round(distance)} km away from the target`);
        }
        
        function testConfetti() {
            console.log('Testing confetti manually...');
            triggerConfetti();
        }
        
        function testCountdown() {
            console.log('Testing countdown manually...');

        }
        
        async function testDuplicateCheck() {
            console.log('Testing duplicate check...');
            const playerName = document.getElementById('player-name')?.value.trim();
            const country = currentGameResult?.country;
            
            if (!playerName || !country) {
                console.log('No player name or country available');
                return;
            }
            
            console.log('Checking for:', { playerName, country });
            
            try {
                const { data: existingScores, error } = await supabase
                    .from('leaderboard')
                    .select('*')
                    .eq('player_name', playerName)
                    .eq('country', country);
                
                console.log('Duplicate check result:', { existingScores, error, count: existingScores?.length || 0 });
            } catch (error) {
                console.error('Error in duplicate check:', error);
            }
        }
        
        function showPuzzleSelector() {
            const puzzleSelector = document.getElementById('puzzle-selector');
            if (puzzleSelector) {
                puzzleSelector.style.display = 'flex';
                console.log('Puzzle selector manually shown');
            } else {
                console.log('Puzzle selector element not found');
            }
        }
        
        function hidePuzzleSelector() {
            const puzzleSelector = document.getElementById('puzzle-selector');
            if (puzzleSelector) {
                puzzleSelector.style.display = 'none';
                console.log('Puzzle selector manually hidden');
            } else {
                console.log('Puzzle selector element not found');
            }
        }
        
        function forceShowPuzzleSelector() {
            const puzzleSelector = document.getElementById('puzzle-selector');
            if (puzzleSelector) {
                puzzleSelector.style.display = 'flex';
                // Save preference to always show
                localStorage.setItem('alwaysShowPuzzleSelector', 'true');
                console.log('Puzzle selector force shown and preference saved');
            } else {
                console.log('Puzzle selector element not found');
            }
        }
        
        function checkPuzzleSelectorStatus() {
            const puzzleSelector = document.getElementById('puzzle-selector');
            const isVisible = puzzleSelector && puzzleSelector.style.display !== 'none';
            const hasCompleted = hasAnyPuzzleBeenCompleted();
            const alwaysShow = localStorage.getItem('alwaysShowPuzzleSelector') === 'true';
            
            console.log('Puzzle Selector Status:', {
                elementExists: !!puzzleSelector,
                isVisible: isVisible,
                hasCompleted: hasCompleted,
                alwaysShowPreference: alwaysShow,
                shouldShow: shouldShowPuzzleSelector()
            });
            
            return { isVisible, hasCompleted, alwaysShow };
        }
        

        
        // Function to show countdown for locked puzzle
        function showLockedPuzzleCountdown(date, puzzle) {
            // Calculate time until puzzle unlocks
            // The puzzle unlocks at 20:00 (8 PM) on the specified date
            const puzzleDate = new Date(date);
            puzzleDate.setHours(20, 0, 0, 0); // Set to 20:00 on puzzle date
            
            const now = new Date();
            const timeUntilUnlock = puzzleDate.getTime() - now.getTime();
            
            if (timeUntilUnlock <= 0) {
                // Puzzle should be unlocked
                alert('This puzzle should be available now! Please refresh the page.');
                return;
            }
            
            // Show countdown text in the puzzle square
            const puzzleSquare = document.getElementById(`puzzle-${date}`);
            
            if (puzzleSquare) {
                // Start countdown timer and update the square content
                startLockedPuzzleCountdown(date, timeUntilUnlock, puzzleSquare);
            } else {
                console.error('Puzzle square not found for date:', date);
            }
        }
        
        // Function to start countdown timer for locked puzzle
        function startLockedPuzzleCountdown(date, initialTime, puzzleSquare) {
            let timeRemaining = initialTime;
            
            const countdownInterval = setInterval(() => {
                if (timeRemaining <= 0) {
                    clearInterval(countdownInterval);
                    // Puzzle is now available
                    puzzleSquare.innerHTML = '<span class="puzzle-number">üéâ</span>';
                    puzzleSquare.title = 'Puzzle is now available!';
                    puzzleSquare.classList.remove('locked');
                    puzzleSquare.classList.add('available');
                    return;
                }
                
                // Calculate time units
                const days = Math.floor(timeRemaining / (1000 * 60 * 60 * 24));
                const hours = Math.floor((timeRemaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000);
                
                // Create countdown text with seconds
                let countdownText = '';
                if (days > 0) {
                    countdownText = `${days}d ${hours}h ${minutes}m ${seconds}s`;
                } else if (hours > 0) {
                    countdownText = `${hours}h ${minutes}m ${seconds}s`;
                } else if (minutes > 0) {
                    countdownText = `${minutes}m ${seconds}s`;
                } else {
                    countdownText = `${seconds}s`;
                }
                
                // Update the puzzle square with countdown
                puzzleSquare.innerHTML = `<span class="puzzle-number">‚è∞</span>`;
                puzzleSquare.title = `Available in ${countdownText}`;
                
                timeRemaining -= 1000; // Decrease by 1 second
            }, 1000);
        }
        

        
        async function showResults() {
            // Ensure puzzle selector is visible (it should already be shown from correctGuess)
            const puzzleSelector = document.getElementById('puzzle-selector');
            if (puzzleSelector) {
                puzzleSelector.style.display = 'flex';
            }
            
            // Show the score submission section
            const scoreSubmission = document.getElementById('score-submission');
            if (scoreSubmission) {
                scoreSubmission.style.display = 'block';
            }
            
            // Update form visibility based on login status
            updateSubmissionFormVisibility();
            
            // Load the leaderboard
            loadGlobalLeaderboard();
            
            // Update puzzle status to show submission states
            await updatePuzzleStatus();
            
            // Show and scroll to the leaderboard section
            const leaderboardSection = document.getElementById('leaderboard-section');
            if (leaderboardSection) {
                leaderboardSection.style.display = 'block';
                leaderboardSection.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start' 
                });
            }
        }
        
        // Function to show leaderboard section (for when no game has been played)
        function showLeaderboardSection() {
            const leaderboardSection = document.getElementById('leaderboard-section');
            if (leaderboardSection) {
                leaderboardSection.style.display = 'block';
            }
        }
        

        

        

        

        
        function triggerConfetti() {
            console.log('Triggering confetti...');
            console.log('tsParticles available:', typeof tsParticles);
            console.log('tsParticles object:', tsParticles);
            
            if (typeof tsParticles !== 'undefined') {
                console.log('Loading particles...');
                try {
                    tsParticles.load({
                    id: "tsparticles",
                    options: {
                        "fullScreen": {
                            "zIndex": 1
                        },
                        "emitters": [
                            {
                                "position": {
                                    "x": 0,
                                    "y": 30
                                },
                                "rate": {
                                        "quantity": 5,
                                    "delay": 0.15
                                },
                                "particles": {
                                    "move": {
                                        "direction": "top-right",
                                        "outModes": {
                                            "top": "none",
                                            "left": "none",
                                            "default": "destroy"
                                        }
                                    }
                                }
                            },
                            {
                                "position": {
                                    "x": 100,
                                    "y": 30
                                },
                                "rate": {
                                    "quantity": 5,
                                    "delay": 0.15
                                },
                                "particles": {
                                    "move": {
                                        "direction": "top-left",
                                        "outModes": {
                                            "top": "none",
                                            "right": "none",
                                            "default": "destroy"
                                        }
                                    }
                                }
                            }
                        ],
                        "particles": {
                            "color": {
                                "value": [
                                    "#ffffff",
                                    "#FF0000"
                                ]
                            },
                            "move": {
                                "decay": 0.05,
                                "direction": "top",
                                "enable": true,
                                "gravity": {
                                    "enable": true
                                },
                                "outModes": {
                                    "top": "none",
                                    "default": "destroy"
                                },
                                "speed": {
                                    "min": 10,
                                    "max": 50
                                }
                            },
                            "number": {
                                "value": 0
                            },
                            "opacity": {
                                "value": 1
                            },
                            "rotate": {
                                "value": {
                                    "min": 0,
                                    "max": 360
                                },
                                "direction": "random",
                                "animation": {
                                    "enable": true,
                                    "speed": 30
                                }
                            },
                            "tilt": {
                                "direction": "random",
                                "enable": true,
                                "value": {
                                    "min": 0,
                                    "max": 360
                                },
                                "animation": {
                                    "enable": true,
                                    "speed": 30
                                }
                            },
                            "size": {
                                "value": {
                                    "min": 0,
                                        "max": 2
                                },
                                "animation": {
                                    "enable": true,
                                    "startValue": "min",
                                    "count": 1,
                                    "speed": 16,
                                    "sync": true
                                }
                            },
                            "roll": {
                                "darken": {
                                    "enable": true,
                                    "value": 25
                                },
                                "enable": true,
                                "speed": {
                                    "min": 5,
                                    "max": 15
                                }
                            },
                            "wobble": {
                                "distance": 30,
                                "enable": true,
                                "speed": {
                                    "min": -7,
                                    "max": "7"
                                }
                            },
                            "shape": {
                                "type": [
                                    "circle",
                                    "square"
                                ],
                                "options": {}
                            }
                        }
                    }
                }).then((container) => {
                    console.log('Particles loaded successfully!');
                    
                    // Stop confetti after 3 seconds
                    setTimeout(() => {
                        try {
                            // Simple cleanup - just destroy the container
                            if (container && typeof container.destroy === 'function') {
                                container.destroy();
                                console.log('Confetti stopped and cleaned up');
                            } else if (container && container.stop) {
                                // Alternative cleanup method
                                container.stop();
                                console.log('Confetti stopped using stop method');
                            } else {
                                // Fallback - hide the container
                                const tsparticlesDiv = document.getElementById('tsparticles');
                                if (tsparticlesDiv) {
                                    tsparticlesDiv.innerHTML = '';
                                    console.log('Confetti container cleared');
                                }
                            }
                        } catch (error) {
                            console.log('Error during confetti cleanup:', error);
                            // Final fallback - clear the container
                            const tsparticlesDiv = document.getElementById('tsparticles');
                            if (tsparticlesDiv) {
                                tsparticlesDiv.innerHTML = '';
                            }
                        }
                    }, 3000);
                    
                }).catch((error) => {
                    console.error('Error loading particles:', error);
                });
                } catch (error) {
                    console.error('Error in triggerConfetti:', error);
                }
            } else {
                console.log('tsParticles library not loaded');
            }
        }
        
        function showDirectionArrow(clickedLat, clickedLng, targetLat, targetLng) {
            const directionText = document.getElementById('direction-text');
            
            if (!directionText) return; // Safety check
            
            // Calculate direction based on coordinates
            const latDiff = targetLat - clickedLat;
            const lngDiff = targetLng - clickedLng;
            
            let direction = '';
            
            // Determine primary direction (latitudinal vs longitudinal)
            if (Math.abs(latDiff) > Math.abs(lngDiff)) {
                // More north/south difference
                if (latDiff > 0) {
                    direction = '‚Üë North';
                } else {
                    direction = '‚Üì South';
                }
            } else {
                // More east/west difference
                if (lngDiff > 0) {
                    direction = '‚Üí East';
                } else {
                    direction = '‚Üê West';
                }
            }
            
            // Add secondary direction if significant
            if (Math.abs(latDiff) > 0.5 && Math.abs(lngDiff) > 0.5) {
                if (latDiff > 0 && lngDiff > 0) {
                    direction = '‚Üó Northeast';
                } else if (latDiff > 0 && lngDiff < 0) {
                    direction = '‚Üñ Northwest';
                } else if (latDiff < 0 && lngDiff > 0) {
                    direction = '‚Üò Southeast';
                } else {
                    direction = '‚Üô Southwest';
                }
            }
            
            directionText.textContent = direction;
        }
        

        
        function highlightCountry(countryName, color) {
            if (!gameMap || !gameGeoData || typeof gameMap.eachLayer !== 'function') return;
            
            // Find and highlight the country
            gameMap.eachLayer((layer) => {
                if (layer.feature && 
                    (layer.feature.properties.name === countryName || 
                     layer.feature.properties.ADMIN === countryName || 
                     layer.feature.properties.NAME === countryName)) {
                    layer.setStyle({
                        fillColor: color,
                        fillOpacity: 0.7,
                        weight: 2
                    });
                }
            });
        }
        
        function resetMapStyling() {
            if (!gameMap || typeof gameMap.eachLayer !== 'function') return;
            
            gameMap.eachLayer((layer) => {
                if (layer.feature) {
                    layer.setStyle({
                        fillColor: '#e2e8f0',
                        fillOpacity: 0.3,
                        weight: 1
                    });
                }
            });
        }
        
        function resetGame(keepCountry = false) {
            gameActive = false;
            
            // Only clear currentCountry if we're not keeping it (for puzzle selection)
            if (!keepCountry) {
                currentCountry = null;
            }
            
            // Stop timer
            if (gameTimer) {
                clearInterval(gameTimer);
                gameTimer = null;
            }
            
            // Reset UI with safety checks
            const timerOverlay = document.getElementById('timer-overlay');
            const directionText = document.getElementById('direction-text');
            const instructionsOverlay = document.querySelector('.instructions-overlay');
            
            if (timerOverlay) timerOverlay.style.display = 'none';
            if (directionText) directionText.textContent = 'Click any country to start';
            if (instructionsOverlay) instructionsOverlay.classList.remove('game-started');
            
            // Reset map
            resetMapStyling();
        }
        

        
        // Helper functions for polygon calculations
        function calculatePolygonCentroid(coordinates) {
            let area = 0;
            let centroidX = 0;
            let centroidY = 0;
            
            for (let i = 0; i < coordinates.length - 1; i++) {
                const cross = coordinates[i][0] * coordinates[i + 1][1] - coordinates[i + 1][0] * coordinates[i][1];
                area += cross;
                centroidX += (coordinates[i][0] + coordinates[i + 1][0]) * cross;
                centroidY += (coordinates[i][1] + coordinates[i + 1][1]) * cross;
            }
            
            area /= 2;
            const factor = 1 / (6 * area);
            
            return [
                factor * centroidX,
                factor * centroidY
            ];
        }
        
        function calculatePolygonArea(coordinates) {
            let area = 0;
            
            for (let i = 0; i < coordinates.length - 1; i++) {
                area += coordinates[i][0] * coordinates[i + 1][1];
                area -= coordinates[i + 1][0] * coordinates[i][1];
            }
            
            return Math.abs(area) / 2;
        }
        async function loadGlobalLeaderboard() {
            if (!supabase) {
                console.error('Supabase client not initialized');
                populateGlobalLeaderboard([]);
                return;
            }
            
            try {
                const { data, error } = await supabase
                    .from('leaderboard')
                    .select('*')
                    .order('time', { ascending: true })
                    .limit(10);
                
                if (error) {
                    if (error.code === 'PGRST205') {
                        console.log('Leaderboard table does not exist yet. Please create it in Supabase dashboard.');
                        populateGlobalLeaderboard([]);
                        return;
                    }
                    throw error;
                }
                
                populateGlobalLeaderboard(data || []);
            } catch (error) {
                console.error('Error loading leaderboard:', error);
                populateGlobalLeaderboard([]);
            }
        }
        
        function populateGlobalLeaderboard(leaderboardData) {
            const leaderboardElement = document.getElementById('leaderboard');
            if (!leaderboardElement) return;
            
            leaderboardElement.innerHTML = '';
            
            if (leaderboardData.length === 0) {
                leaderboardElement.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">No scores yet</p>';
                return;
            }
            
            // Group entries by player to count games, get best scores, and calculate total scores
            const playerStats = {};
            leaderboardData.forEach(entry => {
                if (!playerStats[entry.player_name]) {
                    playerStats[entry.player_name] = {
                        name: entry.player_name,
                        player_flag: entry.player_flag || 'üåç',
                        bestScore: entry.score,
                        bestTime: entry.time,
                        totalScore: entry.score,
                        country: entry.country,
                        gameCount: 1,
                        lastPlayed: entry.date
                    };
                } else {
                    playerStats[entry.player_name].gameCount++;
                    playerStats[entry.player_name].totalScore += entry.score;
                    if (entry.score > playerStats[entry.player_name].bestScore) {
                        playerStats[entry.player_name].bestScore = entry.score;
                        playerStats[entry.player_name].bestTime = entry.time;
                        playerStats[entry.player_name].country = entry.country;
                        playerStats[entry.player_name].lastPlayed = entry.date;
                    }
                }
            });
            
            // Convert to array and sort by total score (highest first)
            const sortedPlayers = Object.values(playerStats).sort((a, b) => b.totalScore - a.totalScore);
            
            sortedPlayers.forEach((player, index) => {
                const leaderboardEntry = document.createElement('div');
                leaderboardEntry.className = 'leaderboard-entry';
                const medal = index < 3 ? ['ü•á', 'ü•à', 'ü•â'][index] : `${index + 1}.`;
                
                leaderboardEntry.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="display: flex; align-items: center;">
                            <span class="medal">${medal}</span>
                            <span class="country-flag">${player.player_flag}</span>
                            <div class="player-info">
                                <strong>${player.name}</strong>
                                <div style="font-size: 0.9rem; color: var(--text-secondary);">
                                   Total: ${player.gameCount} game${player.gameCount > 1 ? 's' : ''} ‚Ä¢ Last Played: ${player.lastPlayed}
                                </div>
                            </div>
                        </div>
                        <div class="score-info">
                            <div style="font-size: 1.2rem; font-weight: bold; color: var(--accent-color);">
                                ${player.totalScore} pts
                            </div>
                            <div style="font-size: 0.9rem; color: var(--text-secondary);">
                                Best: ${player.bestScore} pts ‚Ä¢ ${player.bestTime}s
                            </div>
                        </div>
                    </div>
                `;
                leaderboardElement.appendChild(leaderboardEntry);
            });
        }
        
        async function submitScore() {
            if (!supabase) {
                alert('Leaderboard service not available. Please refresh the page and try again.');
                return;
            }
            
            if (!currentGameResult) {
                alert('No game result to submit! Please play the game first.');
                return;
            }
            
            // Check if user is logged in
            let userLogin = getUserLogin();
            if (!userLogin) {
                // First time user - get name and flag
                const playerName = document.getElementById('player-name').value.trim();
                const playerFlag = window.selectedPlayerFlag;
                
                if (!playerName) {
                    alert('Please enter your name!');
                    return;
                }
                
                if (!playerFlag) {
                    alert('Please select a flag to represent your country!');
                    return;
                }
                
                // Save user login info
                saveUserLogin(playerName, playerFlag);
                userLogin = { playerName, playerFlag };
            }
            
            // Get submit button reference
            const submitBtn = document.querySelector('.submit-score-btn');
            if (!submitBtn) {
                alert('Submit button not found. Please refresh the page.');
                return;
            }
            
            // Check if this device has already submitted a score for this country
            try {
                const { data: existingScores, error: checkError } = await supabase
                    .from('leaderboard')
                    .select('*')
                    .eq('player_name', userLogin.playerName)
                    .eq('country', currentGameResult.country);
                
                if (checkError) {
                    console.error('Error checking existing scores:', checkError);
                    alert('Error checking for duplicate submissions. Please try again.');
                    return;
                } else if (existingScores && existingScores.length > 0) {
                    alert(`You have already submitted a score for ${currentGameResult.country}! You can replay the puzzle, but only your first submission counts for the leaderboard.`);
                    return;
                }
            } catch (error) {
                console.error('Error checking for duplicate submissions:', error);
                alert('Error checking for duplicate submissions. Please try again.');
                return;
            }
            
            // Disable submit button and show submitting state
            submitBtn.disabled = true;
            submitBtn.textContent = 'Submitting...';
            
            try {
                // Format data properly for Supabase
                const scoreData = {
                    player_name: userLogin.playerName,
                    player_flag: userLogin.playerFlag,
                    country: currentGameResult.country,
                    time: parseInt(currentGameResult.time),
                    score: parseInt(currentGameResult.score),
                    date: currentGameResult.date,
                    timestamp: new Date(currentGameResult.timestamp).toISOString()
                };
                
                const { data, error } = await supabase
                    .from('leaderboard')
                    .insert([scoreData]);
                
                if (error) {
                    if (error.code === 'PGRST205') {
                        alert('Leaderboard service not available. Please refresh the page and try again.');
                        submitBtn.disabled = false;
                        submitBtn.textContent = 'Submit Score';
                        return;
                    }
                    
                    // Handle missing column errors
                    if (error.message && error.message.includes('device_id')) {
                        alert('Leaderboard service configuration error. Please contact support.');
                        submitBtn.disabled = false;
                        submitBtn.textContent = 'Submit Score';
                        return;
                    }
                    
                    console.error('Supabase error details:', error);
                    throw error;
                }
                
                // Reload leaderboard to show new score
                await loadGlobalLeaderboard();
                
                // Show success
                submitBtn.textContent = 'Score Submitted!';
                submitBtn.style.background = '#10b981';
                
                // Hide the score submission section after successful submission
                const scoreSubmission = document.getElementById('score-submission');
                if (scoreSubmission) {
                    scoreSubmission.style.display = 'none';
                }
                
                setTimeout(() => {
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Submit Score';
                    submitBtn.style.background = '';
                }, 2000);
                
            } catch (error) {
                console.error('Error submitting score:', error);
                
                let errorMessage = 'Error submitting score. Please try again.';
                if (error.message) {
                    errorMessage = `Error: ${error.message}`;
                } else if (error.details) {
                    errorMessage = `Error: ${error.details}`;
                }
                
                alert(errorMessage);
                submitBtn.disabled = false;
                submitBtn.textContent = 'Submit Score';
            }
        }

        // Interactive World Map Functionality
        let worldMap = null;
        let geoJSONLayer = null;


        // Initialize the world map when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeWorldMap();
            // Load country emojis from Supabase
            loadCountryEmojis();
            // Automatically load countries on startup
            setTimeout(() => {
                toggleGeoJSON();
            }, 1000);
            

        });

        function initializeWorldMap() {
            // Initialize map
            worldMap = L.map('world-map').setView([20, 0], 2);

            // Add completely label-free dark map tiles
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
                attribution: '¬© OpenStreetMap & Carto',
                subdomains: 'abcd',
                maxZoom: 6,
                minZoom: 2
            }).addTo(worldMap);

            // Add click event to show coordinates only (no markers)
            worldMap.on('click', function(e) {
                const lat = e.latlng.lat.toFixed(4);
                const lng = e.latlng.lng.toFixed(4);
                
                // Update coordinates display
                document.getElementById('map-coordinates').textContent = `Lat: ${lat}, Lng: ${lng}`;
            });

            // Update zoom level display
            worldMap.on('zoomend', function() {
                const zoom = worldMap.getZoom();
                document.getElementById('map-zoom').textContent = `Zoom: ${zoom}`;
            });


        }

        // Country descriptions (static, won't change)
        const countryDescriptions = {
            // North America
            'United States': 'Land of the free and home of the brave',
            'Canada': 'Great white north with maple syrup',
            'Mexico': 'Tacos, tequila, and ancient pyramids',
            'Greenland': 'Ice, snow, and northern lights',
            'Cuba': 'Cigars, salsa, and Caribbean culture',
            'Jamaica': 'Reggae, beaches, and jerk chicken',
            'Haiti': 'Vibrant culture and Caribbean spirit',
            'Dominican Republic': 'Baseball, beaches, and merengue',
            'Puerto Rico': 'Island of enchantment and coqui frogs',
            'Panama': 'Canal, rainforests, and biodiversity',
            'Costa Rica': 'Pura vida, coffee, and eco-tourism',
            'Nicaragua': 'Lakes, volcanoes, and colonial cities',
            'Honduras': 'Mayan ruins, beaches, and mountains',
            'El Salvador': 'Pupusas, volcanoes, and Pacific coast',
            'Guatemala': 'Ancient Maya, textiles, and volcanoes',
            'Belize': 'Barrier reef, jungles, and Mayan sites',
            
            // South America
            'Brazil': 'Samba, soccer, and the Amazon rainforest',
            'Argentina': 'Tango, steak, and Patagonia mountains',
            'Chile': 'Wine, mountains, and Easter Island',
            'Peru': 'Machu Picchu, llamas, and ancient Incas',
            'Colombia': 'Coffee, emeralds, and Caribbean coast',
            'Venezuela': 'Angel Falls, oil, and Caribbean beaches',
            'Ecuador': 'Galapagos Islands, volcanoes, and equator',
            'Bolivia': 'Salt flats, mountains, and indigenous culture',
            'Paraguay': 'Guarani culture, rivers, and yerba mate',
            'Uruguay': 'Beaches, mate tea, and peaceful living',
            'Guyana': 'Rainforests, waterfalls, and diverse culture',
            'Suriname': 'Tropical forests, rivers, and Dutch heritage',
            'French Guiana': 'European spaceport and Amazon jungle',
            
            // Europe
            'United Kingdom': 'Tea, rain, and royal traditions',
            'France': 'Baguettes, wine, and the Eiffel Tower',
            'Germany': 'Beer, sausages, and Oktoberfest',
            'Italy': 'Pizza, pasta, and Renaissance art',
            'Spain': 'Paella, flamenco, and sunny beaches',
            'Russia': 'Vodka, bears, and vast landscapes',
            'Portugal': 'Cod, port wine, and Atlantic coast',
            'Netherlands': 'Tulips, windmills, and canals',
            'Belgium': 'Chocolate, waffles, and medieval cities',
            'Switzerland': 'Alps, chocolate, and precision watches',
            'Austria': 'Classical music, schnitzel, and mountains',
            'Poland': 'Pierogi, history, and Baltic coast',
            'Czech Republic': 'Beer, castles, and Prague',
            'Hungary': 'Thermal baths, goulash, and Budapest',
            'Romania': 'Dracula, castles, and Carpathians',
            'Bulgaria': 'Roses, yogurt, and Black Sea coast',
            'Greece': 'Ancient ruins, islands, and Mediterranean',
            'Ukraine': 'Sunflowers, borscht, and rich history',
            'Belarus': 'Forests, potatoes, and Soviet heritage',
            'Lithuania': 'Medieval castles, amber, and Baltic Sea',
            'Latvia': 'Baltic coast, forests, and medieval towns',
            'Estonia': 'Digital innovation and Baltic beauty',
            'Finland': 'Saunas, lakes, and northern lights',
            'Sweden': 'IKEA, meatballs, and midnight sun',
            'Norway': 'Fjords, Vikings, and northern lights',
            'Denmark': 'Hygge, pastries, and fairy tales',
            'Iceland': 'Geysers, volcanoes, and northern lights',
            'Ireland': 'Guinness, leprechauns, and Celtic culture',
            'Scotland': 'Whisky, kilts, and highland games',
            'Wales': 'Dragons, castles, and Celtic heritage',
            'Luxembourg': 'Financial center and European capital',
            'Liechtenstein': 'Alpine principality and banking',
            'Monaco': 'Luxury, casinos, and Formula 1',
            'Andorra': 'Pyrenees mountains and tax haven',
            'San Marino': 'Ancient republic and mountain views',
            'Vatican City': 'Smallest country and Catholic center',
            'Malta': 'Islands, history, and Mediterranean charm',
            'Cyprus': 'Island of love and ancient history',
            'Albania': 'Mountains, beaches, and Ottoman heritage',
            'North Macedonia': 'Mountains, lakes, and ancient history',
            'Kosovo': 'Young nation and Balkan culture',
            'Serbia': 'Balkan culture and Orthodox heritage',
            'Montenegro': 'Adriatic coast and mountain beauty',
            'Bosnia and Herzegovina': 'Bridges, mountains, and diverse culture',
            'Croatia': 'Adriatic coast, islands, and Game of Thrones',
            'Slovenia': 'Alpine beauty and Adriatic coast',
            'Slovakia': 'Mountains, castles, and Slavic culture',
            'Moldova': 'Wine, monasteries, and Eastern European charm',
            
            // Asia
            'China': 'Great Wall, dragons, and ancient culture',
            'Japan': 'Cherry blossoms, sushi, and technology',
            'India': 'Spices, temples, and diverse culture',
            'Pakistan': 'Mountains, spices, and ancient trade routes',
            'Bangladesh': 'Rice, rivers, and Bengal tigers',
            'Thailand': 'Elephants, temples, and street food',
            'Vietnam': 'Pho, rice terraces, and Ho Chi Minh',
            'Malaysia': 'Palm trees, diverse culture, and Petronas',
            'Indonesia': 'Volcanoes, islands, and diverse culture',
            'Philippines': 'Islands, beaches, and friendly people',
            'South Korea': 'K-pop, kimchi, and technology',
            'North Korea': 'Isolated nation with unique culture',
            'Mongolia': 'Nomads, horses, and vast steppes',
            'Kazakhstan': 'Steppes, oil, and Central Asia',
            'Uzbekistan': 'Silk Road, mosques, and ancient cities',
            'Iran': 'Persian culture, carpets, and ancient history',
            'Iraq': 'Mesopotamia, ancient civilization, and rivers',
            'Saudi Arabia': 'Islam, oil, and desert landscapes',
            'Yemen': 'Ancient history and Arabian culture',
            'Oman': 'Desert, mountains, and frankincense',
            'United Arab Emirates': 'Dubai, oil, and modern cities',
            'Qatar': 'Desert, oil, and World Cup 2022',
            'Bahrain': 'Pearls, oil, and island kingdom',
            'Kuwait': 'Oil, desert, and Persian Gulf',
            'Jordan': 'Petra, desert, and biblical history',
            'Lebanon': 'Cedar trees, mountains, and Mediterranean',
            'Syria': 'Ancient history and Mediterranean coast',
            'Israel': 'Holy land, innovation, and diverse culture',
            'Palestine': 'Ancient history and cultural heritage',
            'Georgia': 'Mountains, wine, and Caucasus culture',
            'Armenia': 'First Christian nation and Caucasus heritage',
            'Azerbaijan': 'Oil, mountains, and Caspian Sea',
            'Turkmenistan': 'Desert, gas, and Silk Road history',
            'Tajikistan': 'Mountains, rivers, and Central Asia',
            'Kyrgyzstan': 'Mountains, nomads, and Central Asia',
            'Afghanistan': 'Mountains, history, and crossroads of Asia',
            'Nepal': 'Mountains, temples, and Mount Everest',
            'Bhutan': 'Happiness, mountains, and Buddhist culture',
            'Sri Lanka': 'Tea, beaches, and ancient temples',
            'Maldives': 'Islands, beaches, and coral reefs',
            'Myanmar': 'Temples, rivers, and golden pagodas',
            'Laos': 'Mountains, rivers, and Buddhist culture',
            'Cambodia': 'Angkor Wat, temples, and Khmer history',
            'Brunei': 'Oil, rainforests, and sultanate',
            'East Timor': 'Islands, coffee, and independence',
            'Taiwan': 'Technology, mountains, and island culture',
            'Hong Kong': 'Skyscrapers, harbor, and global finance',
            'Macau': 'Casinos, Portuguese heritage, and gaming',
            
            // Africa
            'South Africa': 'Safari, diamonds, and diverse wildlife',
            'Egypt': 'Pyramids, pharaohs, and the Nile',
            'Nigeria': 'Nollywood, jollof rice, and vibrant culture',
            'Kenya': 'Safari, Maasai warriors, and Mount Kenya',
            'Morocco': 'Desert, souks, and mint tea',
            'Algeria': 'Desert, mountains, and Mediterranean coast',
            'Tunisia': 'Ancient ruins, beaches, and Mediterranean',
            'Libya': 'Desert, oil, and Mediterranean coast',
            'Sudan': 'Nile River, desert, and ancient kingdoms',
            'South Sudan': 'Youngest nation and African culture',
            'Ethiopia': 'Coffee, mountains, and ancient history',
            'Somalia': 'Horn of Africa and Indian Ocean coast',
            'Djibouti': 'Strategic location and Red Sea coast',
            'Eritrea': 'Red Sea coast and mountain highlands',
            'Chad': 'Desert, lake, and Central African culture',
            'Niger': 'Desert, uranium, and West African culture',
            'Mali': 'Desert, gold, and ancient empires',
            'Burkina Faso': 'Sahel region and West African culture',
            'Senegal': 'Atlantic coast and West African culture',
            'Gambia': 'River, beaches, and West African culture',
            'Guinea-Bissau': 'Islands, rivers, and West African culture',
            'Guinea': 'Mountains, minerals, and West African culture',
            'Sierra Leone': 'Beaches, diamonds, and West African culture',
            'Liberia': 'Liberty, beaches, and West African culture',
            'Ivory Coast': 'Cocoa, beaches, and West African culture',
            'Ghana': 'Gold Coast, cocoa, and West African culture',
            'Togo': 'Beaches, mountains, and West African culture',
            'Benin': 'Voodoo, beaches, and West African culture',
            'Cameroon': 'Mountains, rainforests, and Central Africa',
            'Central African Republic': 'Heart of Africa and diverse wildlife',
            'Equatorial Guinea': 'Oil, islands, and Central Africa',
            'Gabon': 'Rainforests, oil, and Central Africa',
            'Republic of the Congo': 'Rainforests, rivers, and Central Africa',
            'Democratic Republic of the Congo': 'Rainforests, minerals, and Central Africa',
            'Angola': 'Oil, beaches, and Southern African culture',
            'Zambia': 'Victoria Falls, copper, and Southern Africa',
            'Zimbabwe': 'Victoria Falls, history, and Southern Africa',
            'Botswana': 'Desert, diamonds, and Southern Africa',
            'Namibia': 'Desert, coast, and Southern African culture',
            'Lesotho': 'Mountain kingdom and Southern Africa',
            'Eswatini': 'Mountains, culture, and Southern Africa',
            'Madagascar': 'Unique wildlife, islands, and Indian Ocean',
            'Comoros': 'Islands, spices, and Indian Ocean',
            'Seychelles': 'Islands, beaches, and Indian Ocean paradise',
            'Mauritius': 'Islands, beaches, and Indian Ocean culture',
            'Cape Verde': 'Islands, music, and Atlantic Ocean',
            'S√£o Tom√© and Pr√≠ncipe': 'Islands, chocolate, and Gulf of Guinea',
            
            // Oceania
            'Australia': 'Kangaroos, beaches, and the Outback',
            'New Zealand': 'Kiwi birds, mountains, and Maori culture',
            'Papua New Guinea': 'Tribal culture, rainforests, and diversity',
            'Fiji': 'Islands, beaches, and Pacific culture',
            'Solomon Islands': 'Islands, rainforests, and Pacific culture',
            'Vanuatu': 'Volcanoes, islands, and Pacific culture',
            'New Caledonia': 'Islands, nickel, and Pacific culture',
            'Samoa': 'Islands, culture, and Pacific heritage',
            'Tonga': 'Islands, monarchy, and Pacific culture',
            'Tuvalu': 'Islands, climate change, and Pacific culture',
            'Kiribati': 'Islands, fishing, and Pacific culture',
            'Nauru': 'Island nation and phosphate mining',
            'Palau': 'Islands, marine life, and Pacific culture',
            'Micronesia': 'Islands, culture, and Pacific heritage',
            'Marshall Islands': 'Islands, nuclear testing, and Pacific culture',
            
            // Additional territories and dependencies
            'French Polynesia': 'Tahiti, islands, and Pacific paradise',
            'American Samoa': 'US territory and Pacific culture',
            'Guam': 'US territory and Pacific island',
            'Northern Mariana Islands': 'US territory and Pacific culture',
            'Hawaii': 'Islands, volcanoes, and Pacific culture',
            'Alaska': 'Mountains, glaciers, and northern wilderness',
            'Puerto Rico': 'US territory and Caribbean culture',
            'US Virgin Islands': 'US territory and Caribbean paradise',
            'British Virgin Islands': 'UK territory and Caribbean culture',
            'Cayman Islands': 'UK territory and financial center',
            'Bermuda': 'UK territory and Atlantic island',
            'Falkland Islands': 'UK territory and South Atlantic',
            'French Guiana': 'French territory and Amazon jungle',
            'Greenland': 'Danish territory and Arctic wilderness',
            'Faroe Islands': 'Danish territory and North Atlantic',
            'Svalbard': 'Norwegian territory and Arctic wilderness',
            'Azores': 'Portuguese territory and Atlantic islands',
            'Madeira': 'Portuguese territory and Atlantic paradise',
            'Canary Islands': 'Spanish territory and Atlantic islands',
            'Ceuta': 'Spanish territory and Mediterranean coast',
            'Melilla': 'Spanish territory and Mediterranean coast',
            'Gibraltar': 'UK territory and Mediterranean rock',
            'Akrotiri and Dhekelia': 'UK territory and Cyprus bases',
            'Christmas Island': 'Australian territory and Indian Ocean',
            'Cocos Islands': 'Australian territory and Indian Ocean',
            'Norfolk Island': 'Australian territory and Pacific Ocean',
            'Heard and McDonald Islands': 'Australian territory and Southern Ocean',
            'Ashmore and Cartier Islands': 'Australian territory and Indian Ocean',
            'Coral Sea Islands': 'Australian territory and Pacific Ocean',
            'Macquarie Island': 'Australian territory and Southern Ocean',
            'Bouvet Island': 'Norwegian territory and Southern Ocean',
            'South Georgia and South Sandwich Islands': 'UK territory and Southern Ocean',
            'British Indian Ocean Territory': 'UK territory and Indian Ocean',
            'Pitcairn Islands': 'UK territory and Pacific Ocean',
            'Tokelau': 'New Zealand territory and Pacific culture',
            'Niue': 'New Zealand territory and Pacific culture',
            'Cook Islands': 'New Zealand territory and Pacific culture',
            'Wallis and Futuna': 'French territory and Pacific culture',
            'New Caledonia': 'French territory and Pacific culture',
            'French Polynesia': 'French territory and Pacific paradise',
            'Clipperton Island': 'French territory and Pacific Ocean',
            'Easter Island': 'Chilean territory and Pacific culture',
            'Juan Fern√°ndez Islands': 'Chilean territory and Pacific Ocean',
            'Gal√°pagos Islands': 'Ecuadorian territory and Pacific wildlife',
            'Fernando de Noronha': 'Brazilian territory and Atlantic Ocean',
            'Saint Helena': 'UK territory and Atlantic Ocean',
            'Ascension Island': 'UK territory and Atlantic Ocean',
            'Tristan da Cunha': 'UK territory and Atlantic Ocean',
            'Gough Island': 'UK territory and Atlantic Ocean',
            'Inaccessible Island': 'UK territory and Atlantic Ocean',
            'Nightingale Islands': 'UK territory and Atlantic Ocean',
            'South Orkney Islands': 'UK territory and Southern Ocean',
            'South Shetland Islands': 'UK territory and Southern Ocean',
            'Peter I Island': 'Norwegian territory and Southern Ocean',
            'Queen Maud Land': 'Norwegian territory and Antarctica',
            'Ross Dependency': 'New Zealand territory and Antarctica',
            'Australian Antarctic Territory': 'Australian territory and Antarctica',
            'Ad√©lie Land': 'French territory and Antarctica',
            'Chilean Antarctic Territory': 'Chilean territory and Antarctica',
            'Argentine Antarctica': 'Argentine territory and Antarctica',
            'British Antarctic Territory': 'UK territory and Antarctica'
        };

        // Country emojis and descriptions cache (will be loaded from Supabase)
        let countryEmojis = new Map();
        let countryDescriptionsCache = new Map();
        const DEFAULT_EMOJI = 'üåç'; // Default emoji for all countries

        // Load country emojis from Supabase
        async function loadCountryEmojis() {
            try {
                if (!supabase) {
                    console.log('Supabase not ready yet, will retry...');
                    setTimeout(loadCountryEmojis, 1000);
                    return;
                }

                console.log('Loading country emojis from Supabase...');
                
                // First, try to get existing emojis
                const { data: existingEmojis, error: fetchError } = await supabase
                    .from('country_emojis')
                    .select('*');
                
                if (fetchError) {
                    console.log('No country_emojis table found, creating default emojis...');
                    await createDefaultEmojis();
                    return;
                }
                
                // Load existing emojis and descriptions into cache
                if (existingEmojis && existingEmojis.length > 0) {
                    existingEmojis.forEach(item => {
                        countryEmojis.set(item.country_name, item.emoji);
                        countryDescriptionsCache.set(item.country_name, item.description);
                    });
                    console.log(`Loaded ${existingEmojis.length} custom emojis and descriptions from Supabase`);
                } else {
                    console.log('No custom emojis found, creating defaults...');
                    await createDefaultEmojis();
                }

                // Refresh map if it's already loaded
                if (geoJSONLayer) {
                    refreshMapEmojis();
                }

            } catch (error) {
                console.error('Error loading country emojis:', error);
                // Fallback to default emojis
                await createDefaultEmojis();
            }
        }

        // Create default emojis for all countries
        async function createDefaultEmojis() {
            try {
                if (!supabase) {
                    console.log('Supabase not ready, cannot create default emojis');
                    return;
                }

                console.log('Creating default emojis for all countries...');
                
                // Prepare default emoji and description data
                const defaultEmojiData = Object.keys(countryDescriptions).map(countryName => ({
                    country_name: countryName,
                    emoji: DEFAULT_EMOJI,
                    description: countryDescriptions[countryName],
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                }));

                // Insert default emojis
                const { data, error } = await supabase
                    .from('country_emojis')
                    .insert(defaultEmojiData);

                if (error) {
                    console.error('Error creating default emojis:', error);
                    // If table doesn't exist, we'll need to create it manually
                    console.log('Please create the country_emojis table in Supabase with columns: country_name, emoji, created_at, updated_at');
                    return;
                }

                console.log('Default emojis created successfully');
                
                // Load them into cache
                defaultEmojiData.forEach(item => {
                    countryEmojis.set(item.country_name, item.emoji);
                    countryDescriptionsCache.set(item.country_name, item.description);
                });

                // Refresh map if it's already loaded
                if (geoJSONLayer) {
                    refreshMapEmojis();
                }
                
            } catch (error) {
                console.error('Error creating default emojis:', error);
            }
        }

        // Update a country's emoji
        async function updateCountryEmoji(countryName, newEmoji) {
            try {
                if (!supabase) {
                    console.error('Supabase not ready');
                    return false;
                }

                console.log(`Updating emoji for ${countryName} to ${newEmoji}`);

                // Get current description
                const currentDescription = countryDescriptionsCache.get(countryName) || countryDescriptions[countryName];

                // Update in Supabase
                const { data, error } = await supabase
                    .from('country_emojis')
                    .upsert({
                        country_name: countryName,
                        emoji: newEmoji,
                        description: currentDescription,
                        updated_at: new Date().toISOString()
                    }, {
                        onConflict: 'country_name'
                    });

                if (error) {
                    console.error('Error updating emoji:', error);
                    return false;
                }

                // Update local cache
                countryEmojis.set(countryName, newEmoji);
                
                // Refresh map emojis
                refreshMapEmojis();
                
                console.log(`Emoji updated successfully for ${countryName}`);
                return true;
                
            } catch (error) {
                console.error('Error updating country emoji:', error);
                return false;
            }
        }

        // Update a country's description
        async function updateCountryDescription(countryName, newDescription) {
            try {
                if (!supabase) {
                    console.error('Supabase not ready');
                    return false;
                }

                console.log(`Updating description for ${countryName} to: ${newDescription}`);

                // Get current emoji
                const currentEmoji = countryEmojis.get(countryName) || DEFAULT_EMOJI;

                // Update in Supabase
                const { data, error } = await supabase
                    .from('country_emojis')
                    .upsert({
                        country_name: countryName,
                        emoji: currentEmoji,
                        description: newDescription,
                        updated_at: new Date().toISOString()
                    }, {
                        onConflict: 'country_name'
                    });

                if (error) {
                    console.error('Error updating description:', error);
                    return false;
                }

                // Update local cache
                countryDescriptionsCache.set(countryName, newDescription);
                
                console.log(`Description updated successfully for ${countryName}`);
                return true;
                
            } catch (error) {
                console.error('Error updating country description:', error);
                return false;
            }
        }

        // Refresh emojis on the map
        function refreshMapEmojis() {
            if (!geoJSONLayer) return;

            geoJSONLayer.eachLayer(function(layer) {
                if (layer.feature && layer.feature.emojiMarkers) {
                    // Remove old emoji markers
                    layer.feature.emojiMarkers.forEach(marker => {
                        worldMap.removeLayer(marker);
                    });
                    layer.feature.emojiMarkers = [];
                }

                // Add new emoji marker
                const countryName = layer.feature.properties.name;
                if (countryName) {
                    const countryInfo = getCountryEmoji(countryName);
                    const center = layer.getBounds().getCenter();
                    
                    const emojiMarker = L.marker(center, {
                        icon: L.divIcon({
                            className: 'country-emoji-marker',
                            html: `<div class="emoji-marker">${countryInfo.emoji}</div>`,
                            iconSize: [30, 30],
                            iconAnchor: [15, 15]
                        }),
                        interactive: false
                    });
                    
                    emojiMarker.addTo(worldMap);
                    
                    // Store reference for cleanup
                    if (!layer.feature.emojiMarkers) {
                        layer.feature.emojiMarkers = [];
                    }
                    layer.feature.emojiMarkers.push(emojiMarker);
                }
            });
        }

        // Change country emoji (called from emoji suggestion buttons)
        async function changeCountryEmoji(countryName, newEmoji) {
            const success = await updateCountryEmoji(countryName, newEmoji);
            if (success) {
                // Close the modal
                const modal = document.querySelector('.country-info-modal');
                if (modal) {
                    modal.remove();
                }
                
                // Show success message
                showToast(`‚úÖ Emoji updated for ${countryName}!`, 'success');
            } else {
                showToast(`‚ùå Failed to update emoji for ${countryName}`, 'error');
            }
        }

        // Set custom emoji from input
        async function setCustomEmoji(countryName) {
            const inputId = `custom-emoji-${countryName.replace(/\s+/g, '-')}`;
            const input = document.getElementById(inputId);
            const customEmoji = input.value.trim();
            
            if (!customEmoji) {
                showToast('Please enter an emoji', 'error');
                return;
            }
            
            // Validate that it's actually an emoji (basic check)
            if (customEmoji.length > 2) {
                showToast('Please enter a valid emoji (max 2 characters)', 'error');
                return;
            }
            
            const success = await updateCountryEmoji(countryName, customEmoji);
            if (success) {
                // Close the modal
                const modal = document.querySelector('.country-info-modal');
                if (modal) {
                    modal.remove();
                }
                
                // Show success message
                showToast(`‚úÖ Custom emoji set for ${countryName}!`, 'success');
            } else {
                showToast(`‚ùå Failed to set custom emoji for ${countryName}`, 'error');
            }
        }

        // Set custom description from input
        async function setCustomDescription(countryName) {
            const textareaId = `custom-description-${countryName.replace(/\s+/g, '-')}`;
            const textarea = document.getElementById(textareaId);
            const customDescription = textarea.value.trim();
            
            if (!customDescription) {
                showToast('Please enter a description', 'error');
                return;
            }
            
            // Validate description length
            if (customDescription.length > 200) {
                showToast('Description is too long (max 200 characters)', 'error');
                return;
            }
            
            const success = await updateCountryDescription(countryName, customDescription);
            if (success) {
                // Show success message
                showToast(`‚úÖ Description updated for ${countryName}!`, 'success');
                
                // Update the description in the modal
                const descriptionElement = document.querySelector('.country-description-large');
                if (descriptionElement) {
                    descriptionElement.textContent = customDescription;
                }
            } else {
                showToast(`‚ùå Failed to update description for ${countryName}`, 'error');
            }
        }

        // Show toast notification
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast-notification toast-${type}`;
            toast.textContent = message;
            
            // Add styles
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#22c55e' : type === 'error' ? '#ef4444' : '#3b82f6'};
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                font-family: 'Inter', sans-serif;
                font-size: 14px;
                z-index: 10001;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                animation: slideIn 0.3s ease;
            `;
            
            document.body.appendChild(toast);
            
            // Remove after 3 seconds
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // Get emoji and description for a country
        function getCountryEmoji(countryName) {
            const emoji = countryEmojis.get(countryName) || DEFAULT_EMOJI;
            const description = countryDescriptionsCache.get(countryName) || countryDescriptions[countryName] || 'A beautiful country';
            return { emoji, description };
        }



        // Show country info interface with emoji editing
        function showCountryInfo(countryName, countryInfo) {
            // Create a modal to show country information
            const modal = document.createElement('div');
            modal.className = 'country-info-modal';
            modal.innerHTML = `
                <div class="country-info-content">
                    <div class="country-info-header">
                        <h2>${countryName}</h2>
                        <button class="close-btn" onclick="this.closest('.country-info-modal').remove()">&times;</button>
                    </div>
                    
                    <div class="country-info-body">
                        <div class="country-display">
                            <div class="country-emoji-large">${countryInfo.emoji}</div>
                            <div class="country-description-large">${countryInfo.description}</div>
                        </div>
                        
                        <div class="editors-container">
                            <div class="emoji-editor">
                                <h3>Change Emoji</h3>
                                <div class="emoji-suggestions">
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'ü•ñ')">ü•ñ</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üç∫')">üç∫</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üçï')">üçï</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'ü•ò')">ü•ò</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üêª')">üêª</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üêâ')">üêâ</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üóæ')">üóæ</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üïâÔ∏è')">üïâÔ∏è</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'ü¶ò')">ü¶ò</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'ü¶Å')">ü¶Å</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üè∫')">üè∫</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üé≠')">üé≠</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'ü¶í')">ü¶í</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üê™')">üê™</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üïå')">üïå</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üç∑')">üç∑</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'ü¶ô')">ü¶ô</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üåä')">üåä</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üåã')">üåã</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üêü')">üêü</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üå∑')">üå∑</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üç´')">üç´</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üèîÔ∏è')">üèîÔ∏è</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üéµ')">üéµ</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'ü•ü')">ü•ü</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üõÅ')">üõÅ</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üè∞')">üè∞</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üåπ')">üåπ</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üèõÔ∏è')">üèõÔ∏è</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üåª')">üåª</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üå≤')">üå≤</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üåæ')">üåæ</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üêé')">üêé</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'ü•ù')">ü•ù</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üå∫')">üå∫</button>
                                    <button class="emoji-suggestion" onclick="changeCountryEmoji('${countryName}', 'üåç')">üåç</button>
                                </div>
                                <div class="custom-emoji-input">
                                    <input type="text" id="custom-emoji-${countryName.replace(/\s+/g, '-')}" placeholder="Or type custom emoji (e.g., üöÄ)" maxlength="2" class="emoji-input">
                                    <button onclick="setCustomEmoji('${countryName}')" class="set-emoji-btn">Set Custom</button>
                                </div>
                            </div>
                            
                            <div class="description-editor">
                                <h3>Change Description</h3>
                                <div class="description-input-container">
                                    <textarea id="custom-description-${countryName.replace(/\s+/g, '-')}" placeholder="Enter a new description for ${countryName}" class="description-input" rows="3" maxlength="200">${countryInfo.description}</textarea>
                                    <button onclick="setCustomDescription('${countryName}')" class="set-description-btn">Update Description</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add styles
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;
            
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        

        

        

        

        

        
        // Helper function to create polygon path
        function createPolygonPath(coordinates) {
            if (!coordinates || coordinates.length === 0) return '';
            
            let path = 'M ';
            coordinates.forEach((coord, index) => {
                if (index === 0) {
                    path += `${coord[0]} ${coord[1]}`;
                } else {
                    path += ` L ${coord[0]} ${coord[1]}`;
                }
            });
            path += ' Z';
            return path;
        }
        
        // Helper function to create multipolygon path
        function createMultiPolygonPath(coordinates) {
            if (!coordinates || coordinates.length === 0) return '';
            
            let path = '';
            coordinates.forEach(polygon => {
                if (polygon && polygon[0]) {
                    path += createPolygonPath(polygon[0]) + ' ';
                }
            });
            return path.trim();
        }

        // Close country upload modal



        


        // Upload country image
        async function uploadCountryImage() {
            const fileInput = document.getElementById('country-image-upload');
            const urlInput = document.getElementById('country-image-url');
            const statusDiv = document.getElementById('upload-status');
            const countryName = document.getElementById('upload-country-name').textContent.replace('Upload Image for ', '');
            
            let imageUrl = '';
            
            // Check if file is selected
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                // For now, we'll use a reliable placeholder URL
                imageUrl = getReliablePlaceholder(countryName);
                statusDiv.textContent = 'File upload feature requires Supabase Storage setup. Using reliable placeholder image.';
            } else if (urlInput.value.trim()) {
                imageUrl = urlInput.value.trim();
            } else {
                statusDiv.textContent = 'Please select a file or enter an image URL.';
                statusDiv.style.display = 'block';
                statusDiv.style.background = '#ef4444';
                return;
            }
            
            try {
                console.log('Attempting to save image for country:', countryName, 'URL:', imageUrl);
                
                // Validate the image URL first
                statusDiv.textContent = 'Validating image URL...';
                statusDiv.style.background = '#f59e0b';
                statusDiv.style.display = 'block';
                
                const isValidImage = await validateImageUrl(imageUrl);
                if (!isValidImage) {
                    console.warn('Image URL validation failed, but continuing...');
                    statusDiv.textContent = 'Warning: Image URL validation failed, but saving anyway...';
                    statusDiv.style.background = '#f59e0b';
                }
                
                // First try to insert, if it fails due to conflict, then update
                console.log('Attempting to insert new country image...');
                let { data, error } = await supabase
                    .from('country_images')
                    .insert({
                        country_name: countryName,
                        image_url: imageUrl
                    });
                
                console.log('Insert result:', { data, error });
                
                // If insert fails due to duplicate, try update
                if (error && error.code === '23505') { // Unique constraint violation
                    console.log('Country already exists, updating...');
                    const { data: updateData, error: updateError } = await supabase
                        .from('country_images')
                        .update({ image_url: imageUrl })
                        .eq('country_name', countryName);
                    
                    console.log('Update result:', { data: updateData, error: updateError });
                    
                    if (updateError) {
                        throw updateError;
                    }
                    data = updateData;
                } else if (error) {
                    throw error;
                }
                
                // Update local cache
                countryImages.set(countryName.toLowerCase(), imageUrl);
                
                // Show success message
                statusDiv.textContent = 'Image uploaded successfully!';
                statusDiv.style.background = '#22c55e';
                statusDiv.style.display = 'block';
                
                // Close modal after 2 seconds
                setTimeout(() => {
                    closeCountryUploadModal();
                    // Refresh the map to show the new image
                    if (geoJSONLayer) {
                        console.log('Refreshing map to show new image...');
                        // Remove current layer and reload
                        worldMap.removeLayer(geoJSONLayer);
                        geoJSONLayer = null;
                        // Reload after a short delay
                        setTimeout(() => {
                            toggleGeoJSON();
                        }, 500);
                    }
                }, 2000);
                
            } catch (error) {
                console.error('Error uploading country image:', error);
                console.error('Error details:', {
                    message: error.message,
                    code: error.code,
                    details: error.details,
                    hint: error.hint
                });
                
                let errorMessage = 'Error uploading image. Please try again.';
                if (error.message) {
                    errorMessage = `Error: ${error.message}`;
                }
                
                statusDiv.textContent = errorMessage;
                statusDiv.style.background = '#ef4444';
                statusDiv.style.display = 'block';
            }
        }

        // Toggle GeoJSON countries layer
        function toggleGeoJSON() {
            if (geoJSONLayer) {
                // Remove all emoji markers when hiding the layer
                if (geoJSONLayer.eachLayer) {
                    geoJSONLayer.eachLayer(function(layer) {
                        if (layer.feature && layer.feature.emojiMarkers) {
                            layer.feature.emojiMarkers.forEach(marker => {
                                worldMap.removeLayer(marker);
                            });
                        }
                    });
                }
                worldMap.removeLayer(geoJSONLayer);
                geoJSONLayer = null;
            } else {
                // Load the actual countries.geojson file
                fetch('countries.geojson')
                    .then(response => response.json())
                    .then(data => {
                        geoJSONLayer = L.geoJSON(data, {
                            style: {
                                color: '#ffffff',
                                weight: 1,
                                opacity: 0.8,
                                fillOpacity: 0.1
                            },
                            onEachFeature: function(feature, layer) {
                                const countryName = feature.properties.name;
                                
                                // Add hover effects
                                layer.on({
                                    mouseover: function(e) {
                                        e.target.setStyle({
                                            color: '#ffffff',
                                            weight: 2,
                                            fillOpacity: 0.3
                                        });
                                        
                                        // Show country info tooltip
                                        const countryInfo = getCountryEmoji(countryName);
                                        const tooltip = L.tooltip({
                                            permanent: false,
                                            direction: 'top',
                                            className: 'country-tooltip'
                                        })
                                        .setContent(`
                                            <div class="country-tooltip-content">
                                                <div class="country-emoji">${countryInfo.emoji}</div>
                                                <div class="country-name">${countryName}</div>
                                                <div class="country-description">${countryInfo.description}</div>
                                            </div>
                                        `)
                                        .setLatLng(e.latlng);
                                        
                                        layer.bindTooltip(tooltip);
                                        layer.openTooltip();
                                    },
                                    mouseout: function(e) {
                                        geoJSONLayer.resetStyle(e.target);
                                        layer.closeTooltip();
                                    }
                                });
                                
                                // Add country emoji marker at center
                                if (countryName) {
                                    const countryInfo = getCountryEmoji(countryName);
                                    const center = layer.getBounds().getCenter();
                                    
                                    const emojiMarker = L.marker(center, {
                                        icon: L.divIcon({
                                            className: 'country-emoji-marker',
                                            html: `<div class="emoji-marker">${countryInfo.emoji}</div>`,
                                            iconSize: [30, 30],
                                            iconAnchor: [15, 15]
                                        }),
                                        interactive: false
                                    });
                                    
                                    emojiMarker.addTo(worldMap);
                                    
                                    // Store reference for cleanup
                                    if (!feature.emojiMarkers) {
                                        feature.emojiMarkers = [];
                                    }
                                    feature.emojiMarkers.push(emojiMarker);
                                }
                                
                                // Add click event to show country info
                                layer.on('click', function(e) {
                                    const countryInfo = getCountryEmoji(countryName);
                                    showCountryInfo(countryName, countryInfo);
                                });
                            }
                        }).addTo(worldMap);
                    })
                    .catch(error => {
                        console.error('Error loading countries data:', error);
                    });
            }
        }

        // Reset map view

    </script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tsparticles@2.12.0/tsparticles.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</body>
</html>
