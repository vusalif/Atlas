<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Atlas - Multiplayer Duel Mode</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    :root {
      --bg: #0a0a0a;
      --fg: #ffffff;
      --muted: #666666;
      --accent: #00ff88;
      --danger: #ff4444;
      --panel: #1a1a1a;
      --map-bg: #0a0a0a;
      --card-bg: #1a1a1a;
      --border-color: #333333;
      --page-bg: #0a0a0a;
      --player1-color: #ff4444;
      --player2-color: #4444ff;
      --success: #00ff88;
      --warning: #ffaa00;
      --info: #4444ff;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    
    body {
      background: var(--page-bg);
      color: var(--fg);
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 14px;
      line-height: 1.5;
      overflow: hidden;
    }
    
    #app {
      height: 100%;
      position: relative;
    }
    
    #map {
      height: 100%;
      width: 100%;
      background: var(--map-bg);
    }
    
    .leaflet-container {
      background: var(--map-bg);
    }
    
    /* Centered UI Container */
    .ui-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 20px;
      max-width: 400px;
      width: 90%;
    }
    
    /* Card Design */
    .card {
      background: var(--card-bg);
      border: 2px solid var(--border-color);
      border-radius: 12px;
      padding: 24px;
      backdrop-filter: blur(20px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    .card h3 {
      margin: 0 0 20px 0;
      color: var(--accent);
      font-size: 18px;
      font-weight: 600;
      text-align: center;
    }
    
    /* Room Management */
    .room-creation {
      text-align: center;
    }
    
    .input-group {
      margin-bottom: 20px;
    }
    
    .input-group label {
      display: block;
      margin-bottom: 10px;
      color: var(--fg);
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.9;
    }
    
    .input-group input {
      width: 100%;
      padding: 16px 20px;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      background: var(--bg);
      color: var(--fg);
      font-size: 16px;
      font-weight: 500;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    
    .input-group input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 4px rgba(0, 255, 136, 0.15), 0 4px 16px rgba(0, 0, 0, 0.2);
      transform: translateY(-1px);
    }
    
    .input-group input::placeholder {
      color: var(--muted);
      font-weight: 400;
    }
    
    /* Button Design */
    .btn {
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 12px;
      padding: 16px 28px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.3s ease;
      min-width: 140px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 4px 16px rgba(0, 255, 136, 0.2);
    }
    
    .btn:hover {
      background: #00cc6a;
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0, 255, 136, 0.4);
    }
    
    .btn.secondary {
      background: var(--muted);
      box-shadow: 0 4px 16px rgba(102, 102, 102, 0.2);
    }
    
    .btn.secondary:hover {
      background: #555555;
      box-shadow: 0 8px 25px rgba(102, 102, 102, 0.4);
    }
    
    .btn.danger {
      background: var(--danger);
      box-shadow: 0 4px 16px rgba(255, 68, 68, 0.2);
    }
    
    .btn.danger:hover {
      background: #cc3333;
      box-shadow: 0 8px 25px rgba(255, 68, 68, 0.4);
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    /* Button Group */
    .btn-group {
      display: flex;
      gap: 16px;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 24px;
    }
    
    /* Room Info */
    .room-info {
      background: var(--bg);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .room-id {
      font-family: 'Monaco', 'Menlo', monospace;
      background: linear-gradient(135deg, var(--accent) 0%, #00cc6a 100%);
      padding: 16px 24px;
      border-radius: 12px;
      color: var(--bg);
      font-weight: 900;
      font-size: 20px;
      text-align: center;
      margin-bottom: 20px;
      letter-spacing: 2px;
      box-shadow: 0 4px 16px rgba(0, 255, 136, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.2);
    }
    
    .room-status {
      text-align: center;
      color: var(--muted);
      font-size: 14px;
      margin-bottom: 16px;
    }
    
    /* Player List */
    .player-list {
      margin: 20px 0;
    }
    
    .player-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      margin-bottom: 8px;
    }
    
    .player-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: bold;
      color: var(--bg);
    }
    
    .player-status {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-left: auto;
    }
    
    .player-status.online { background: var(--success); }
    .player-status.ready { background: var(--warning); }
    .player-status.playing { background: var(--danger); }
    
    /* Game Panel */
    .game-panel {
      display: none;
      background: var(--card-bg);
      border: 2px solid var(--border-color);
      border-radius: 16px;
      padding: 32px;
      backdrop-filter: blur(20px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    .game-status {
      text-align: center;
      margin-bottom: 32px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .timer {
      font-size: 48px;
      font-weight: 900;
      color: var(--accent);
      margin-bottom: 16px;
      font-family: 'Monaco', 'Menlo', monospace;
      text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
      letter-spacing: 2px;
    }
    
    .current-player {
      font-size: 18px;
      color: var(--fg);
      text-transform: uppercase;
      letter-spacing: 2px;
      font-weight: 600;
      background: rgba(0, 255, 136, 0.1);
      padding: 8px 16px;
      border-radius: 8px;
      border: 1px solid rgba(0, 255, 136, 0.3);
    }
    
    .players-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 24px;
      width: 100%;
    }
    
    .player-card {
      padding: 24px 20px;
      border-radius: 12px;
      border: 3px solid transparent;
      text-align: center;
      transition: all 0.3s ease;
      background: var(--card-bg);
      position: relative;
      min-height: 120px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    
    .player-card.active {
      border-color: var(--accent);
      box-shadow: 0 0 25px rgba(0, 255, 136, 0.4);
      transform: translateY(-2px);
    }
    
    .player-card.player1 {
      border-color: var(--player1-color);
      background: linear-gradient(135deg, var(--card-bg) 0%, rgba(255, 68, 68, 0.1) 100%);
    }
    
    .player-card.player2 {
      border-color: var(--player2-color);
      background: linear-gradient(135deg, var(--card-bg) 0%, rgba(68, 68, 255, 0.1) 100%);
    }
    
    .player-name {
      font-weight: 700;
      margin-bottom: 8px;
      font-size: 18px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .player1 .player-name { 
      color: var(--player1-color);
      text-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
    }
    .player2 .player-name { 
      color: var(--player2-color);
      text-shadow: 0 0 10px rgba(68, 68, 255, 0.5);
    }
    
    .player-score {
      font-size: 32px;
      font-weight: 900;
      margin-bottom: 8px;
      color: var(--accent);
      text-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
    }
    
    .player-target {
      font-size: 11px;
      color: var(--muted);
      min-height: 16px;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 600;
      background: rgba(255, 255, 255, 0.05);
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    /* Chat Panel */
    .chat-panel {
      display: none;
    }
    
    .chat-messages {
      height: 200px;
      overflow-y: auto;
      background: var(--bg);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 16px;
    }
    
    .chat-message {
      margin-bottom: 12px;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
    }
    
    .chat-message.system {
      background: rgba(68, 68, 255, 0.1);
      color: var(--info);
      font-style: italic;
    }
    
    .chat-message.player {
      background: rgba(0, 255, 136, 0.1);
      color: var(--accent);
    }
    
    .chat-input {
      display: flex;
      gap: 12px;
    }
    
    .chat-input input {
      flex: 1;
      padding: 12px 16px;
      border: 2px solid var(--border-color);
      border-radius: 8px;
      background: var(--bg);
      color: var(--fg);
      font-size: 14px;
    }
    
    .chat-input input:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .chat-input button {
      padding: 12px 20px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    /* Status Messages */
    .status-message {
      padding: 12px 16px;
      border-radius: 8px;
      margin-bottom: 20px;
      font-size: 14px;
      font-weight: 500;
      text-align: center;
    }
    
    .status-message.success {
      background: rgba(0, 255, 136, 0.1);
      border: 2px solid var(--success);
      color: var(--success);
    }
    
    .status-message.error {
      background: rgba(255, 68, 68, 0.1);
      border: 2px solid var(--danger);
      color: var(--danger);
    }
    
    .status-message.info {
      background: rgba(68, 68, 255, 0.1);
      border: 2px solid var(--info);
      color: var(--info);
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .ui-container {
        width: 95%;
        max-width: 350px;
      }
      
      .card {
        padding: 20px;
      }
      
      .players-container {
        grid-template-columns: 1fr;
        gap: 12px;
      }
      
      .btn-group {
        flex-direction: column;
        align-items: center;
      }
      
      .btn {
        width: 100%;
        max-width: 200px;
      }
    }
    
    /* Hide elements by default */
    .hidden {
      display: none !important;
    }
    
    /* Smooth transitions */
    .card, .btn, .player-card {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="map"></div>
    
    <div class="ui-container">
      <!-- Room Management Card -->
      <div class="card room-panel">
        <h3>üè† Create or Join Room</h3>
        
        <div id="roomCreation" class="room-creation">
          <div class="input-group">
            <label>Your Name</label>
            <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
          </div>
          
          <div class="btn-group">
            <button id="createRoomBtn" class="btn">Create Room</button>
            <button id="joinRoomBtn" class="btn secondary">Join Room</button>
          </div>
          
          <div id="joinRoomInput" class="input-group hidden">
            <label>Room ID</label>
            <input type="text" id="roomIdInput" placeholder="Enter room ID">
            <button id="joinRoomConfirmBtn" class="btn" style="margin-top: 16px;">Join Room</button>
          </div>
        </div>
        
        <div id="roomInfo" class="room-info hidden">
          <div id="roomId" class="room-id"></div>
          <div id="roomStatus" class="room-status">Waiting for players...</div>
          <div class="player-list" id="playerList"></div>
          <div class="btn-group">
            <button id="startGameBtn" class="btn" disabled>Start Game</button>
            <button id="leaveRoomBtn" class="btn danger">Leave Room</button>
          </div>
        </div>
        
        <div id="statusMessage"></div>
      </div>
      
      <!-- Game Panel Card -->
      <div class="card game-panel" id="gamePanel">
        <h3>üéÆ Game</h3>
        
        <div class="game-status">
          <div id="gameTimer" class="timer">01:00</div>
          <div id="currentPlayerDisplay" class="current-player">Waiting...</div>
        </div>
        
        <div class="players-container">
          <div id="player1Card" class="player-card player1">
            <div class="player-name" id="player1Name">Player 1</div>
            <div class="player-score" id="player1Score">0</div>
            <div class="player-target" id="player1Target">Waiting...</div>
          </div>
          
          <div id="player2Card" class="player-card player2">
            <div class="player-name" id="player2Name">Player 2</div>
            <div class="player-score" id="player2Score">0</div>
            <div class="player-target" id="player2Target">Waiting...</div>
          </div>
        </div>
        
        <div class="btn-group">
          <button id="readyBtn" class="btn">Ready</button>
          <button id="pauseBtn" class="btn secondary hidden">Pause</button>
          <button id="resumeBtn" class="btn secondary hidden">Resume</button>
        </div>
      </div>
      
      <!-- Chat Panel Card -->
      <div class="card chat-panel" id="chatPanel">
        <h3>üí¨ Chat</h3>
        <div id="chatMessages" class="chat-messages"></div>
        <div class="chat-input">
          <input type="text" id="chatInput" placeholder="Type a message..." maxlength="100">
          <button id="sendChatBtn">Send</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script>
    // Game state
    const gameState = {
      playerId: '',
      playerName: '',
      roomId: null,
      isHost: false,
      players: [],
      gameStarted: false,
      currentPlayer: null,
      player1Id: null,
      player2Id: null,
      scores: {},
      targets: {},
      timeLeft: 60,
      timer: null,
      map: null,
      layer: null,
      features: [],
      completedCountries: new Set()
    };

    // WebSocket connection
    let socket = null;
    const SERVER_URL = 'ws://localhost:3000'; // Local development server

    // Initialize map
    function initMap() {
      gameState.map = L.map('map', {
        worldCopyJump: true,
        preferCanvas: false,
        zoomSnap: 0.5,
        zoomDelta: 0.5,
      }).setView([20, 0], 2);

      const tileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
        maxZoom: 6,
        minZoom: 2,
        attribution: '&copy; OpenStreetMap & Carto',
        subdomains: 'abcd'
      }).addTo(gameState.map);

      loadCountries();
    }

    // Load country data
    async function loadCountries() {
      try {
        const response = await fetch('./countries.geojson');
        const data = await response.json();
        gameState.features = data.features.filter(f => {
          const name = pickName(f.properties);
          return name && !['Antarctica'].includes(name);
        });
        
        buildMapLayer();
        console.log(`Loaded ${gameState.features.length} countries`);
      } catch (error) {
        console.error('Failed to load countries:', error);
        showStatus('Failed to load country data', 'error');
      }
    }

    // Build map layer
    function buildMapLayer() {
      if (gameState.layer) gameState.layer.remove();

      gameState.layer = L.geoJSON(gameState.features, {
        style: { color: '#2c3e50', weight: 1, fillColor: '#60a5fa', fillOpacity: 0.08 },
        onEachFeature: (feature, layer) => {
          layer.on({
            mouseover: (e) => e.target.setStyle({ weight: 2, fillOpacity: 0.25 }),
            mouseout: (e) => gameState.layer.resetStyle(e.target),
            click: (e) => onCountryClick(feature, e.target)
          });
        }
      }).addTo(gameState.map);
    }

    // Country click handler
    function onCountryClick(feature, layer) {
      if (!gameState.gameStarted || !gameState.currentPlayer) return;
      
      const clickedCountry = pickName(feature.properties);
      const currentTarget = gameState.targets[gameState.currentPlayer];
      
      if (!currentTarget) return;
      
      const targetCountry = pickName(currentTarget.properties);
      
      if (clickedCountry === targetCountry) {
        // Correct guess
        const playerKey = gameState.currentPlayer;
        gameState.scores[playerKey] = (gameState.scores[playerKey] || 0) + 1;
        
        // Style the country based on player
        const isPlayer1 = playerKey === gameState.player1Id;
        const style = isPlayer1 ? 
          { fillColor: '#ff4444', fillOpacity: 0.35 } : 
          { fillColor: '#4444ff', fillOpacity: 0.35 };
        layer.setStyle(style);
        
        // Remove events
        layer.off('click');
        layer.off('mouseover');
        layer.off('mouseout');
        
        // Mark as completed
        gameState.completedCountries.add(clickedCountry);
        
        // Update display
        updateScoreDisplay();
        
        // Send move to server
        if (socket) {
          socket.send(JSON.stringify({
            type: 'correct_guess',
            player: playerKey,
            country: clickedCountry,
            score: gameState.scores[playerKey]
          }));
        }
        
        // Switch players
        switchPlayer();
        
      } else {
        // Wrong guess
        layer.setStyle({ fillColor: '#ffaa00', fillOpacity: 0.35 });
        
        // Send move to server
        if (socket) {
          socket.send(JSON.stringify({
            type: 'wrong_guess',
            player: gameState.currentPlayer,
            country: clickedCountry
          }));
        }
        
        // Switch players
        switchPlayer();
      }
    }

    // Switch players
    function switchPlayer() {
      gameState.currentPlayer = gameState.currentPlayer === gameState.player1Id ? gameState.player2Id : gameState.player1Id;
      updateCurrentPlayerDisplay();
      setNewTarget();
    }

    // Set new target for current player
    function setNewTarget() {
      const playerKey = gameState.currentPlayer;
      const availableCountries = gameState.features.filter(f => {
        const name = pickName(f.properties);
        return !gameState.completedCountries.has(name);
      });
      
      if (availableCountries.length === 0) {
        endGame();
        return;
      }
      
      const randomCountry = availableCountries[Math.floor(Math.random() * availableCountries.length)];
      gameState.targets[playerKey] = randomCountry;
      
      // Update display - find the correct target element
      const isPlayer1 = playerKey === gameState.player1Id;
      const targetElement = document.getElementById(isPlayer1 ? 'player1Target' : 'player2Target');
      if (targetElement) {
        targetElement.textContent = pickName(randomCountry.properties);
      }
    }

    // Update score display
    function updateScoreDisplay() {
      if (gameState.player1Id && gameState.player2Id) {
        document.getElementById('player1Score').textContent = gameState.scores[gameState.player1Id] || 0;
        document.getElementById('player2Score').textContent = gameState.scores[gameState.player2Id] || 0;
      }
    }

    // Update current player display
    function updateCurrentPlayerDisplay() {
      const display = document.getElementById('currentPlayerDisplay');
      const player1Card = document.getElementById('player1Card');
      const player2Card = document.getElementById('player2Card');
      
      if (gameState.currentPlayer === gameState.player1Id) {
        const player1Name = gameState.players.find(p => p.id === gameState.player1Id)?.name || 'Player 1';
        display.textContent = `${player1Name}'s Turn`;
        player1Card.classList.add('active');
        player2Card.classList.remove('active');
      } else {
        const player2Name = gameState.players.find(p => p.id === gameState.player2Id)?.name || 'Player 2';
        display.textContent = `${player2Name}'s Turn`;
        player2Card.classList.add('active');
        player1Card.classList.remove('active');
      }
    }

    // Start game (called by host)
    function startGame() {
      if (gameState.players.length < 2) {
        showStatus('Need at least 2 players to start', 'error');
        return;
      }
      
      // Send start game message to server
      if (socket) {
        socket.send(JSON.stringify({
          type: 'start_game',
          roomId: gameState.roomId
        }));
        showStatus('Starting game...', 'info');
      } else {
        showStatus('Not connected to server', 'error');
      }
    }
    
    // Start game from server (called for both players)
    function startGameFromServer() {
      console.log('Starting game from server...');
      
      // Reset map
      if (gameState.layer) {
        gameState.layer.eachLayer(layer => {
          gameState.layer.resetStyle(layer);
          layer.on({
            mouseover: (e) => e.target.setStyle({ weight: 2, fillOpacity: 0.25 }),
            mouseout: (e) => gameState.layer.resetStyle(e.target),
            click: (e) => onCountryClick(layer.feature, e.target)
          });
        });
      }
      
      // Set initial targets
      setNewTarget();
      switchPlayer();
      setNewTarget();
      
      // Start timer
      startTimer();
      
      // Update UI
      document.getElementById('startGameBtn').disabled = true;
      document.getElementById('gamePanel').style.display = 'block';
      document.getElementById('chatPanel').style.display = 'block';
      
      showStatus('Game started!', 'success');
    }

    // Start timer
    function startTimer() {
      if (gameState.timer) clearInterval(gameState.timer);
      
      gameState.timer = setInterval(() => {
        gameState.timeLeft--;
        updateTimerDisplay();
        
        if (gameState.timeLeft <= 0) {
          endGame();
        }
      }, 1000);
    }

    // Update timer display
    function updateTimerDisplay() {
      const minutes = Math.floor(gameState.timeLeft / 60);
      const seconds = gameState.timeLeft % 60;
      document.getElementById('gameTimer').textContent = 
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    // End game
    function endGame() {
      if (gameState.timer) clearInterval(gameState.timer);
      
      gameState.gameStarted = false;
      
      // Determine winner
      let winner = 'tie';
      if (gameState.player1Id && gameState.player2Id) {
        const player1Score = gameState.scores[gameState.player1Id] || 0;
        const player2Score = gameState.scores[gameState.player2Id] || 0;
        
        if (player1Score > player2Score) {
          winner = gameState.player1Id;
        } else if (player2Score > player1Score) {
          winner = gameState.player2Id;
        }
      }
      
      const winnerName = winner === 'tie' ? 'Tie' : 
        gameState.players.find(p => p.id === winner)?.name || winner;
      
      showStatus(`Game Over! Winner: ${winnerName}`, 'info');
      
      // Send to server
      if (socket) {
        socket.send(JSON.stringify({
          type: 'game_ended',
          roomId: gameState.roomId,
          winner: winner,
          scores: gameState.scores
        }));
      }
    }

    // Create room
    function createRoom() {
      const playerName = document.getElementById('playerName').value.trim();
      if (!playerName) {
        showStatus('Please enter your name', 'error');
        return;
      }
      
      gameState.playerName = playerName;
      gameState.isHost = true;
      gameState.playerId = generatePlayerId();
      
      // Generate room ID
      gameState.roomId = generateRoomId();
      
      // Add yourself as player 1
      gameState.players = [{
        id: gameState.playerId,
        name: playerName,
        status: 'online',
        isHost: true
      }];
      
      // Update UI
      document.getElementById('roomCreation').classList.add('hidden');
      document.getElementById('roomInfo').classList.remove('hidden');
      document.getElementById('roomId').textContent = gameState.roomId;
      updatePlayerList();
      
      showStatus('Room created! Share the Room ID with others', 'success');
      
      // Connect to server
      connectToServer();
    }

    // Join room
    function joinRoom() {
      const playerName = document.getElementById('playerName').value.trim();
      if (!playerName) {
        showStatus('Please enter your name', 'error');
        return;
      }
      
      gameState.playerName = playerName;
      document.getElementById('joinRoomInput').classList.remove('hidden');
    }

    // Confirm join room
    function confirmJoinRoom() {
      const roomId = document.getElementById('roomIdInput').value.trim();
      if (!roomId) {
        showStatus('Please enter room ID', 'error');
        return;
      }
      
      gameState.roomId = roomId;
      gameState.isHost = false;
      gameState.playerId = generatePlayerId();
      
      // Add yourself as player 2
      gameState.players = [{
        id: gameState.playerId,
        name: gameState.playerName,
        status: 'online',
        isHost: false
      }];
      
      // Update UI
      document.getElementById('roomCreation').classList.add('hidden');
      document.getElementById('roomInfo').classList.remove('hidden');
      document.getElementById('roomId').textContent = gameState.roomId;
      updatePlayerList();
      
      showStatus('Joined room! Waiting for host to start...', 'success');
      
      // Connect to server
      connectToServer();
    }

    // Generate room ID
    function generateRoomId() {
      return Math.random().toString(36).substring(2, 8).toUpperCase();
    }
    
    // Generate player ID
    function generatePlayerId() {
      return 'player_' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    }
    
    // Add chat message
    function addChatMessage(playerName, message) {
      const chatMessages = document.getElementById('chatMessages');
      if (chatMessages) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'chat-message';
        messageDiv.innerHTML = `
          <span class="chat-player">${playerName}:</span>
          <span class="chat-text">${message}</span>
        `;
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
    }
    
    // Send chat message
    function sendChatMessage() {
      const chatInput = document.getElementById('chatInput');
      const message = chatInput.value.trim();
      
      if (!message || !socket) return;
      
      // Send to server
      socket.send(JSON.stringify({
        type: 'chat_message',
        message: message
      }));
      
      // Clear input
      chatInput.value = '';
    }

    // Update player list
    function updatePlayerList() {
      const playerList = document.getElementById('playerList');
      playerList.innerHTML = '';
      
      gameState.players.forEach(player => {
        const playerItem = document.createElement('div');
        playerItem.className = 'player-item';
        playerItem.innerHTML = `
          <div class="player-avatar">${player.name.charAt(0).toUpperCase()}</div>
          <span>${player.name}</span>
          <div class="player-status ${player.status}"></div>
          ${player.isHost ? '<span style="color: var(--accent);">üëë</span>' : ''}
        `;
        playerList.appendChild(playerItem);
      });
      
      // Update player names in game panel
      if (gameState.players.length > 0) {
        document.getElementById('player1Name').textContent = gameState.players[0].name;
      }
      if (gameState.players.length > 1) {
        document.getElementById('player2Name').textContent = gameState.players[1].name;
      }
      
      // Enable start button if host and 2 players
      const startBtn = document.getElementById('startGameBtn');
      if (startBtn) {
        startBtn.disabled = !(gameState.isHost && gameState.players.length >= 2);
      }
    }

    // Connect to server
    function connectToServer() {
      console.log('Connecting to server...');
      
      try {
        // Create WebSocket connection
        socket = new WebSocket(`${SERVER_URL}?playerId=${gameState.playerId}&roomId=${gameState.roomId}&name=${encodeURIComponent(gameState.playerName)}`);
        
        socket.onopen = () => {
          console.log('Connected to server');
          showStatus('Connected to server', 'success');
        };
        
        socket.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            handleServerMessage(data);
          } catch (error) {
            console.error('Error parsing server message:', error);
          }
        };
        
        socket.onclose = () => {
          console.log('Disconnected from server');
          showStatus('Disconnected from server', 'error');
          socket = null;
        };
        
        socket.onerror = (error) => {
          console.error('WebSocket error:', error);
          showStatus('Connection error', 'error');
        };
        
      } catch (error) {
        console.error('Failed to connect to server:', error);
        showStatus('Failed to connect to server', 'error');
      }
    }
    
    // Handle messages from server
    function handleServerMessage(data) {
      console.log('Received server message:', data);
      
      switch (data.type) {
        case 'room_info':
          // Update room information
          if (data.room && data.room.players) {
            gameState.players = data.room.players.map(p => ({
              id: p.id,
              name: p.name,
              status: p.status,
              isHost: p.isHost
            }));
            updatePlayerList();
          }
          break;
          
        case 'player_joined':
          // New player joined
          if (data.player) {
            gameState.players.push({
              id: data.player.id,
              name: data.player.name,
              status: data.player.status,
              isHost: data.player.isHost
            });
            updatePlayerList();
            showStatus(`${data.player.name} joined the room!`, 'success');
          }
          break;
          
        case 'player_left':
          // Player left
          gameState.players = gameState.players.filter(p => p.id !== data.playerId);
          updatePlayerList();
          showStatus('A player left the room', 'warning');
          break;
          
        case 'game_started':
          // Game started by host
          if (data.gameState) {
            console.log('Game started from server:', data);
            gameState.gameStarted = true;
            gameState.currentPlayer = data.gameState.currentPlayer;
            gameState.scores = data.gameState.scores;
            gameState.timeLeft = data.gameState.timeLeft;
            
            // Update player roles
            if (data.player1 && data.player2) {
              gameState.player1Id = data.player1.id;
              gameState.player2Id = data.player2.id;
            }
            
            // Start the game for both players
            startGameFromServer();
          }
          break;
          
        case 'chat_message':
          // Handle chat message
          addChatMessage(data.playerName, data.message);
          break;
          
        default:
          console.log('Unknown message type:', data.type);
      }
    }

    // Show status message
    function showStatus(message, type = 'info') {
      const statusDiv = document.getElementById('statusMessage');
      statusDiv.className = `status-message ${type}`;
      statusDiv.textContent = message;
      
      setTimeout(() => {
        statusDiv.textContent = '';
        statusDiv.className = 'status-message';
      }, 5000);
    }

    // Utility functions
    function pickName(properties) {
      return properties.name || properties.ADMIN || properties.NAME_LONG || properties.NAME || properties.SOVEREIGNT || properties.BRK_NAME;
    }

    // Event listeners
    document.getElementById('createRoomBtn').addEventListener('click', createRoom);
    document.getElementById('joinRoomBtn').addEventListener('click', joinRoom);
    document.getElementById('joinRoomConfirmBtn').addEventListener('click', confirmJoinRoom);
    document.getElementById('startGameBtn').addEventListener('click', startGame);
    document.getElementById('leaveRoomBtn').addEventListener('click', () => {
      location.reload();
    });
    
    // Chat event listeners
    document.getElementById('sendChatBtn').addEventListener('click', sendChatMessage);
    document.getElementById('chatInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        sendChatMessage();
      }
    });

    // Initialize
    initMap();
  </script>
</body>
</html>
